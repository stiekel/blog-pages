<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不可能不确定</title>
  <icon>https://www.gravatar.com/avatar/f32bfa1ba5253733bda102536b94ee58</icon>
  <subtitle>A Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chensd.com/"/>
  <updated>2021-03-10T23:07:38.710Z</updated>
  <id>http://chensd.com/</id>
  
  <author>
    <name>Stiekel</name>
    <email>histkc@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的 2017 技术流水账</title>
    <link href="http://chensd.com/2017-12/2017-my-technology-logs.html"/>
    <id>http://chensd.com/2017-12/2017-my-technology-logs.html</id>
    <published>2017-12-31T06:25:31.000Z</published>
    <updated>2021-03-10T23:07:38.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="再见，AngularJS"><a href="#再见，AngularJS" class="headerlink" title="再见，AngularJS"></a>再见，AngularJS</h3><p>第一次使用 AngularJS 是在 2014 年，那时候正在做一个回合制的手游项目，编写后端的同时，也顺手编写了 GM 工具和 Web 页战斗模拟工具，为了方便，整个工具全部写在一个页面中。页面交互全部使用 jQuery 完成，写到中后期，已经被获取表单数据、绑定事件、修改 DOM 元素折腾得不行。于是尝试了 AngularJS ，整个人都感觉不一样了，完全是像写后端代码一样写前端代码。尤其是双向数据绑定，实在是解决了 GM 工具等管理平台中的痛点——大量数量的处理。AngularJS 结合 Bootstrap，简直是编写管理后台的大杀器。</p><p>可是随着单页应用的规模越来越大， AngularJS 的劣势也日益明显，虽然服务可以实现 JavaScript 代码的复用，但这还不够。指令虽然实现了 JavaScript 和 HTML 的复用，使用又太过繁琐。双向绑定虽然方便，但这种随意到处修改值的结果就是值变化了你也不知道是哪里改的。代码文件的组织，也只能按照 JavaScript / HTML / CSS 分别组织。文件打包最多用用 Browserify + Gulp。无论从本身的技术，还是从社区的环境来看， AngularJS 的确已经是过去的技术了。</p><h3 id="你好，Vue"><a href="#你好，Vue" class="headerlink" title="你好，Vue"></a>你好，Vue</h3><p>去年的时候，已经开始陆续试用 React 和 Vue 1.x ，React 的热更新、彻底的组件化、完整的 ES6 支持，实在是让人兴奋。不过我始终没有习惯 JSX ，而 Vue 1.x 的革命性又稍显不足。但 Vue 2.0 的面世，彻底征服了我，博取众家之长，新的生态工具的支持，在简单的尝试之后，很快便投入了 Vue 2 的怀抱。现在的管理后台，基本都是 Vue + Element-ui 的组合。</p><h3 id="干净利落，ES6"><a href="#干净利落，ES6" class="headerlink" title="干净利落，ES6"></a>干净利落，ES6</h3><p>转移到 Vue 2 便可以在整个项目中使用 ES6 了。最喜欢的还是简洁的箭头函数和放心使用的局部变量，再加上 eslint 的强制语法检查，让所有人都编写格式一致的代码。唯一不爽的就是我喜欢的 <code>&#39;sid&#39; === name</code> 的写法要放弃了。</p><h3 id="快快快，Elasticsearch"><a href="#快快快，Elasticsearch" class="headerlink" title="快快快，Elasticsearch"></a>快快快，Elasticsearch</h3><p>Elasticsearch 的确是所有的后端开发人员都该试一试的技术，让人震惊的速度，与生俱来的备份机制，几乎完全零配置开箱即用， DSL 可能相对 SQL 要复杂一些，但入门也还好。</p><p>有了 Elasticsearch ，与数据存储和统计相关的事情，几乎都不再是问题。在 MySQL 中有了几百万数据，想要流畅的查询统计，就得开始规划字段建立索引了，在 Elasticsearch 中完全不用考虑，更何况它的统计功能经甩 MySQL 无数条街。还不提 Elasticsearch 最强大的检索功能。</p><p>Elasticsearch 是今年让我最有幸福感的技术。</p><h3 id="浅尝辙止，Python-Go"><a href="#浅尝辙止，Python-Go" class="headerlink" title="浅尝辙止，Python / Go"></a>浅尝辙止，Python / Go</h3><p>前不久一个项目，需要获取图片 hash，查了一下 Python 这方面的库比较丰富，于是看了一下 Python 的语法就上手了，花了半天工夫折腾出来。后来看到还有 Go 的版本，便也试了一下。运行结果有点震惊，Go 比 Python 快了至少 5 倍，果然 CPU 密集的事情，还是编译语言比较拿手。Go 的 defer 和强制代码格式 gofmt，给我留下了深刻的印象。感觉是时候开始一个新的后端语言了。</p><h3 id="半途而废，Docker"><a href="#半途而废，Docker" class="headerlink" title="半途而废，Docker"></a>半途而废，Docker</h3><p>原计划是准备放弃 VirtualBox，不过 Docker 并不能方便的执行各种 linux 命令，它更偏重于代码的运行环境，而我现在又基本不再掌控后端，所以对我的意义已经不大。Docker 最终便没有用到工作之中。</p><h3 id="Github-Desktop"><a href="#Github-Desktop" class="headerlink" title="Github Desktop"></a>Github Desktop</h3><p>SourceTree 现在是越来越慢了，而且经常需要打开关闭项目 Tab 之后才能发现文件修改，启动也很慢。终于我开始了新的 Git GUI 工具的选择，最没有抱希望的 Github Desktop 却是我最终的选择。超出想像的快，简洁的界面，虽然不支持 ssh key 登陆，功能也比较简陋，但只要速度快，小问题是可以忍受的。</p><h3 id="Coding-NET"><a href="#Coding-NET" class="headerlink" title="Coding.NET"></a>Coding.NET</h3><p>已经用了两三年 Coding.NET 了，以前码币容易挣的时候，还换了件 T 恤，开始是个人使用，后来推广到团队使用，出了企业版后，还动员公司也付了费。但现在免费用户取消了 Coding Pages 自定义域名功能，后来还限制五个私有项目，这让 Coding.NET 成为了另一个被放弃的服务。</p><p>2017 的最后一天，用 Gogs 搭建了自己的 Git 服务，花 6 块钱把 n 年前的花生壳账号做了个认证，开始了自建之路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;再见，AngularJS&quot;&gt;&lt;a href=&quot;#再见，AngularJS&quot; class=&quot;headerlink&quot; title=&quot;再见，AngularJS&quot;&gt;&lt;/a&gt;再见，AngularJS&lt;/h3&gt;&lt;p&gt;第一次使用 AngularJS 是在 2014 年，那时候正
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="账单" scheme="http://chensd.com/tags/%E8%B4%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>打造一个安全的用户名密码登录系统</title>
    <link href="http://chensd.com/2016-08/Safe-username-password-Login-System.html"/>
    <id>http://chensd.com/2016-08/Safe-username-password-Login-System.html</id>
    <published>2016-07-31T23:08:04.000Z</published>
    <updated>2021-03-10T23:07:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>很多的网络应用都有基于用户名密码的登录功能，而绝大多数的登录都毫无安全性可言，不夸张的说，大多数的程序员根本不知道怎样去保证用户名和密码的安全。</p><h2 id="安全的标准"><a href="#安全的标准" class="headerlink" title="安全的标准"></a>安全的标准</h2><p>要想一个登录系统安全，至少要保证以下几个方面。</p><h3 id="原始密码的安全"><a href="#原始密码的安全" class="headerlink" title="原始密码的安全"></a>原始密码的安全</h3><p>很多人对于用户的原始密码安全，还停留在不被非法第三方获取的层面上，但实际上，原始密码的最大威胁，往往来自于系统的开发人员和服务器的管理人员。这些人可能是有意收集，也可能是无意泄露，往往是用户原始密码的泄露的罪魁祸首。在构建登录系统的时候，应该从根本上避免，做到只有用户自己和键盘记录器才知道原始密码。</p><p>那如何做到这一点呢？首先一点就是一定要在客户端进行密码加密，这可以使得后端拿到的密码已经是加过密的，一来服务器接触不到原始密码，二来就算通信被监听，第三方就算拿到了可以用来登录的客户端加密密文，也无法获知用户的原始密码。</p><h3 id="哈希：不可逆加密"><a href="#哈希：不可逆加密" class="headerlink" title="哈希：不可逆加密"></a>哈希：不可逆加密</h3><p>密码加密不同于普通的加密，一是内容重要，二是密码的验证根本不需要原文，要检查一个密码是否正确，只需要看它加密的结果与正确的密码加密的结果是否一致即可。确定了这两点，对于加密的方法，就只要求同一个字符串加密后会得到同样的密文。哈希完全满足了这一要求。</p><p>在哈希算法中，首选是 SHA2 系列，虽然安全由于 SHA1 的原因而被质疑，但至少目前还没有证明有什么纰漏。MD5 由于用得太多，而且彩虹表实在过于泛滥，并不推荐使用。</p><p>另外一个问题，哈希一遍是不是就够了呢？当然不，不仅要多次哈希，而且还要与用户名一类的数据混加，比如，可以使用下面的方式来在客户端加密原始密码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sha256(</span><br><span class="line">  sha265(sha265(password)) + sha265(username)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样，不仅可以增加密文反推原文的难度，还加入用户名，使得就算密码相同，不同用户的密文也完全不一样。</p><p>在客户端的加密，基本上也就只能到这一步了，因为一个最主要的问题是，客户端的加密算法是公开的。</p><h3 id="盐：混入随机数据"><a href="#盐：混入随机数据" class="headerlink" title="盐：混入随机数据"></a>盐：混入随机数据</h3><p>虽然在客户端对密码进行了加密，但无论是算法，还是混入的用户名，都是公开了的。剩下的加密，就需要留给后端了。</p><p>由于对同一字符串进行哈希的结果是恒定的，所以知道了算法和密文，理论上是可以反推出密码的，反推的难度取决于用户原始密码的复杂度。那如何才能够让反推的难度指数级增大呢？答案是在原始密码密文的基础之上，再加入一个随机字符串，从而达到让用户的密码更复杂的效果。这个随机字符串，便是盐。</p><p>后端获取到客户端传来的密码之后，再通过加盐哈希进行再加密。比如像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sha256(</span><br><span class="line">  sha256(username + sha256(password + salt)) + salt + sha256(username + salt)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意，盐的保存非常关键，务必将它与用户信息分开存放。</p><h3 id="密文和盐的更新与不可追溯"><a href="#密文和盐的更新与不可追溯" class="headerlink" title="密文和盐的更新与不可追溯"></a>密文和盐的更新与不可追溯</h3><p>现在密码已经分别在客户端和后端多次哈希，还加了盐，好像已经很安全了。但其实，我们还可以更安全。那就是经常变更盐，让用户信息表中的密文字段值也经常变化。这样，除非同时拿到用户信息和盐，否则依然无效。</p><p>那什么时候变更盐和密文呢？由于后端是不存储客户端哈希的密文的，所以只有在登录的时候，才能够进行盐和密文的修改。</p><h3 id="用户名本身可以加密吗？"><a href="#用户名本身可以加密吗？" class="headerlink" title="用户名本身可以加密吗？"></a>用户名本身可以加密吗？</h3><p>这个想法好像有点不靠谱，但实际上，用户名如果只是作为单纯的登录凭证，其实是可以像密码一样加密的。因为无论是注册、登录还是找回密码，都不需要用户名的原文。但注意，用户名只能哈希，不能加盐，否则就没什么依据去找盐了。</p><p>用户名的哈希可以分两部分，一是客户端哈希，到了服务器端，可以进行再次哈希。</p><p>在本文的 Demo 中，将不对用户名哈希。</p><h3 id="通信的安全"><a href="#通信的安全" class="headerlink" title="通信的安全"></a>通信的安全</h3><p>在应用层面基本上已经很安全了。接下来就是客户端和通信的安全。客户端的环境基本不可控，所以只能在通信的安全上想办法了。不过其实也不用想什么多的办法，直接使用 HTTPS 就行了。</p><h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><p>上面总结了怎样保证一个用户名密码登录系统的安全，这里再来看看一个满足上述要求的登录系统的登录流程。注册流程相对来讲简单一些，所以就不再详细介绍。</p><p><a href="https://github.com/stiekel/safe-username-password-login" target="_blank" rel="noopener">Demo</a> 是一个简单的 Web 用户名密码登录系统，代码示例也取自于它。</p><h3 id="浏览器登录"><a href="#浏览器登录" class="headerlink" title="浏览器登录"></a>浏览器登录</h3><p>浏览器主要完成以下工作：</p><ul><li>获取用户输入的用户名及密码</li><li>通过输入的用户名和密码，进行哈希，得到浏览器端密文</li><li>将用户名和密文提交给后端</li></ul><p>主要代码如下，取自 <a href="https://github.com/stiekel/safe-username-password-login/blob/master/client/app.js" target="_blank" rel="noopener">client/app.js</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 密码与用户名的哈希</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encryptPwd</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">  username = username.toLowerCase();</span><br><span class="line">  <span class="keyword">return</span> sha256(</span><br><span class="line">    username + sha256 (</span><br><span class="line">      sha256(sha256(sha256(password))) + sha256(username)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scope.login = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 检查用户名和密码的合法性，比如是否输入，长度是否足够等</span></span><br><span class="line">  <span class="keyword">if</span>($scope.check()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  $scope.successMessage = <span class="string">''</span>;</span><br><span class="line">  $scope.errorMessage = <span class="string">''</span>;</span><br><span class="line">  $scope.status = <span class="string">'loading'</span>;</span><br><span class="line">  <span class="comment">// 向后端提交登录请求</span></span><br><span class="line">  $resource(<span class="string">'/user/login'</span>)</span><br><span class="line">  .save(&#123;</span><br><span class="line">    username: $scope.username,</span><br><span class="line">    password: encryptPwd($scope.username, $scope.password)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    $scope.status = <span class="string">'done'</span>;</span><br><span class="line">    $scope.successMessage = <span class="string">'login successful!'</span>;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    $scope.status = <span class="string">'done'</span>;</span><br><span class="line">    $scope.errorMessage = reason.data || <span class="string">'failed'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后端密码验证"><a href="#后端密码验证" class="headerlink" title="后端密码验证"></a>后端密码验证</h3><p>后端的验证流程如下：</p><ul><li>获取前端提交的用户名及浏览器端密文</li><li>根据用户名，在数据库中查询出对应的盐 id </li><li>通过盐 id 取出对应的盐，再通过用户名、浏览器端密文和盐算出后端密文</li><li>根据用户名和后端密文到用户表查询，如果有结果，则表明登录信息正确，返回给浏览器登录成功的响应</li><li>生成新的盐，算出新的后端密文，并将两者更新到数据库中</li></ul><p>实现的代码如下，取自 <a href="https://github.com/stiekel/safe-username-password-login/blob/master/app/controllers/user.server.controller.js" target="_blank" rel="noopener">app/controllers/user.server.controller.js</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encryptPwd</span>(<span class="params">usr, pwd, salt</span>)</span>&#123;</span><br><span class="line">  usr = usr.toLowerCase();</span><br><span class="line">  <span class="keyword">return</span> sha256(</span><br><span class="line">    sha256(usr + sha256(pwd + salt)) + salt + sha256(usr + salt)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 用户名密码获取和检查已省略</span></span><br><span class="line">  <span class="comment">// 根据用户名，获取盐 id</span></span><br><span class="line">  req.models.user</span><br><span class="line">  .findOne(&#123;<span class="attr">select</span>:[<span class="string">'username'</span>, <span class="string">'saltId'</span>], <span class="attr">where</span>: &#123;<span class="attr">username</span>: username&#125;&#125;)</span><br><span class="line">  .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, userDoc</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</span><br><span class="line">    <span class="keyword">if</span>(!userDoc) <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'username not exists'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取盐</span></span><br><span class="line">    req.models.salt</span><br><span class="line">    .findOne(&#123;<span class="attr">id</span>: userDoc.saltId&#125;)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, saltDoc</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</span><br><span class="line">      <span class="keyword">if</span>(!saltDoc) <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'can NOT find salt'</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据用户名、密码和盐推算出密文</span></span><br><span class="line">      <span class="keyword">var</span> pwdHash = encryptPwd(username, password, saltDoc.salt);</span><br><span class="line">      <span class="comment">// 在数据库中核对用户名和密文</span></span><br><span class="line">      req.models.user</span><br><span class="line">      .findOne(&#123;<span class="attr">select</span>: [<span class="string">'id'</span>], <span class="attr">where</span>: &#123;<span class="attr">username</span>: username, <span class="attr">password</span>: pwdHash &#125;&#125;)</span><br><span class="line">      .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, doc</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</span><br><span class="line">        <span class="keyword">if</span>(!doc) <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'password error'</span>));</span><br><span class="line"></span><br><span class="line">        res.json(&#123;</span><br><span class="line">          username: username</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> updateSalt(saltDoc, userDoc, password, next);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="盐与密文的更新"><a href="#盐与密文的更新" class="headerlink" title="盐与密文的更新"></a>盐与密文的更新</h3><p>前面返回给用户成功登录的响应之后，调用了更新盐和密文的方法，该方法具体流程如下：</p><ul><li>生成并存储新盐</li><li>根据新盐、用户名和浏览器端密文，生成新的后端密文</li><li>存储后端密文到用户信息表</li></ul><p>实现如下，取自 <a href="https://github.com/stiekel/safe-username-password-login/blob/master/app/controllers/user.server.controller.js" target="_blank" rel="noopener">app/controllers/user.server.controller.js</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateSalt</span>(<span class="params">saltDoc, userDoc, passwordInputed, next</span>)</span>&#123;</span><br><span class="line">  saltDoc.salt = <span class="built_in">Math</span>.random().toString(<span class="number">15</span>).substr(<span class="number">3</span>, <span class="number">27</span>);</span><br><span class="line">  saltDoc.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</span><br><span class="line">    userDoc.password = encryptPwd(userDoc.username, passwordInputed, saltDoc.salt);</span><br><span class="line">    userDoc.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</span><br><span class="line">      <span class="keyword">return</span> next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/stiekel/safe-username-password-login" target="_blank" rel="noopener">Demo</a> 托管在 Github 上。前端采用 AngularJS + Bootstrap ，后端使用 Node.js + Express + MongoDB ，是一个典型的 MEAN 应用 。</p><p>数据存储这块，使用了 Waterline 这个 ORM 中间件（以前也曾经写过两篇介绍文章，可供参考：<a href="http://chensd.com/2015-10/Node-ORM-Waterline.html">Node.js ORM 数据操作中间件 Waterline</a>、<a href="http://chensd.com/2015-10/Use-Waterline-in-Express-project.html">在 Express 项目中使用 Waterline</a>）。使用它的目的主要是为了将用户信息和盐存储到不同的地方。本例中将盐用 <a href="https://github.com/balderdashy/sails-disk" target="_blank" rel="noopener">sails-disk</a> 存储到了文件中，用户信息用 <a href="https://github.com/balderdashy/sails-mongo" target="_blank" rel="noopener">sails-mongo</a> 存储到了 MongoDB 中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/stiekel/safe-username-password-login.git</span><br><span class="line"><span class="built_in">cd</span> safe-username-password-login</span><br><span class="line">npm i</span><br><span class="line">npm i -g gulp</span><br><span class="line">gulp</span><br></pre></td></tr></table></figure><p>再在浏览器中打开 <a href="http://localhost:7102/" target="_blank" rel="noopener">http://localhost:7102/</a> 即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多的网络应用都有基于用户名密码的登录功能，而绝大多数的登录都毫无安全性可言，不夸张的说，大多数的程序员根本不知道怎样去保证用户名和密码的安全。&lt;/p&gt;
&lt;h2 id=&quot;安全的标准&quot;&gt;&lt;a href=&quot;#安全的标准&quot; class=&quot;headerlink&quot; title=&quot;安全
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
      <category term="Waterline" scheme="http://chensd.com/tags/Waterline/"/>
    
      <category term="Express" scheme="http://chensd.com/tags/Express/"/>
    
      <category term="安全" scheme="http://chensd.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Angular 控制器之间的数据共享与通信</title>
    <link href="http://chensd.com/2016-07/Data-share-and-communication-between-Angular-Controllers.html"/>
    <id>http://chensd.com/2016-07/Data-share-and-communication-between-Angular-Controllers.html</id>
    <published>2016-07-27T22:02:45.000Z</published>
    <updated>2021-03-10T23:07:38.713Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS 本身已经提供了像指令 Directive 和 服务 Service 一类的方式，来实现数据和代码的共享和复用，但在实际的项目开发中，或许是处于懒惰，亦或是为了便利，总会想在两个控制器之间，直接进行数据的共享<br>通信，或者是函数与方法的调用，这里我们就看看有哪些方法可以满足这个要求。</p><h2 id="单例服务"><a href="#单例服务" class="headerlink" title="单例服务"></a>单例服务</h2><p>单例服务是 AngularJS 本身支持的数据和代码共享方式，因为是单例的，所有的控制器访问的便是同一份数据。比如，下面的 Service 便可以实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .service(<span class="string">'ObjectService'</span>, [ObjectService]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectService</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(id)&#123;</span><br><span class="line">      <span class="keyword">return</span> list[id];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(id, v)&#123;</span><br><span class="line">      list[id] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个控制器中，调用 <code>ObjectService.set(&#39;i&#39;, 1)</code> 设置的数据，在其它控制器中，便可以通过  <code>ObjectService.get(&#39;i&#39;)</code> 来获取。</p><h2 id="广播与事件"><a href="#广播与事件" class="headerlink" title="广播与事件"></a>广播与事件</h2><p>AngularJS 中在触发事件和发送广播时，都可以传递参数，可以通过这一特性，来实现数据的共享。与事件和广播相关的，共有三个方法，分别是：</p><ul><li><code>$emit()</code>：触发事件，它可以向上传递数据，比如，子控制器向父控制器，还有控制器向 <code>$rootScope</code></li><li><code>$broadcast()</code>：发送广播，它可以向下传递数据，比如，父控制器向子控制器传递数据，或者 <code>$rootScope</code> 向任意控制器传递数据</li><li><code>$on()</code>：监听事件与广播，可以捕获 <code>$emit</code> 和 <code>$broadcast</code></li></ul><p>可以将控制器之间的通信，分为三种情形：</p><ul><li>无直接关联的控制器：使用 <code>$rootScope.$emit()</code>、<code>$rootScope.$boardcast()</code> 或 <code>$scope.$emit</code> 来发出数据，通过 <code>$rootScope.$on()</code> 来获取数据</li><li>父控制器到子控制器：父控制器使用 <code>$scope.$boradcast()</code> 来发送数据，子控制器通过 <code>$scope.$on()</code> 来获取数据</li><li>子控制器至父控制器：子控制器使用 <code>$scope.$emit()</code> 来发送数据，父控制器通过 <code>$scope.$on()</code> 来获取数据</li></ul><p>下面是简单的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one controller</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'OneController'</span>, [<span class="string">'$scope'</span>, OneController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OneController</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = &#123;<span class="attr">value</span>: <span class="string">'test'</span>&#125;;</span><br><span class="line">  $rootScope.$broadcast(<span class="string">'open.notice.editor'</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other controller</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'AnotherController'</span>, [<span class="string">'$scope'</span>, AnotherController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherController</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  $scope.$on(<span class="string">'open.notice.editor'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, data</span>)</span>&#123;</span><br><span class="line">    $scope.open(data);</span><br><span class="line">    $scope.$emit(<span class="string">'notice.editor.opened'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父控制器"><a href="#父控制器" class="headerlink" title="父控制器"></a>父控制器</h2><p>如果两个控制器共同拥有同一个父控制器，则可以通过父控制器来进行数据共享和通信。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ParentController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ChildOneController"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ChildTwoController"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父控制器</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'ParentController'</span>, [<span class="string">'$scope'</span>, ParentController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentController</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 用于传递数据的变量</span></span><br><span class="line">  $scope.data = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子控制器</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'ChildOneController'</span>, [<span class="string">'$scope'</span>, ChildOneController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildOneController</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 数据设置</span></span><br><span class="line">  $scope.$parent.data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子控制器</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'ChildTwoController'</span>, [<span class="string">'$scope'</span>, <span class="string">'$timeout'</span>, ChildTwoController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildTwoController</span>(<span class="params">$scope, $timeout</span>)</span>&#123;</span><br><span class="line">  $timeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 数据读取</span></span><br><span class="line">    <span class="built_in">console</span>.log($scope.$parent.data);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局或共用的变量"><a href="#全局或共用的变量" class="headerlink" title="全局或共用的变量"></a>全局或共用的变量</h2><p>AngularJS 提供了对 <code>window</code> 和 <code>localStorage</code> 两个变量的封装，<code>$window</code> 和 <code>$localStorage</code> ，通过修改和监听这两个值，可以达到在控制器之间数据共享和通信的目的。方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one controller</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'OneController'</span>, [<span class="string">'$scope'</span>, <span class="string">'$window'</span>, OneController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OneController</span>(<span class="params">$scope, $window</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 数据设置</span></span><br><span class="line">  $<span class="built_in">window</span>.data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other controller</span></span><br><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'AnotherController'</span>, [<span class="string">'$scope'</span>, AnotherController]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherController</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 监听修改</span></span><br><span class="line">  $scope.$watch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="built_in">window</span>.data;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    $scope.windowData = n;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这种监听修改的方式，也可以用在其它通信方式中。</p><h2 id="元素绑定"><a href="#元素绑定" class="headerlink" title="元素绑定"></a>元素绑定</h2><p>AngularJS 中，可以通过一个元素，来获取其上的控制器实例。通过这种方式便可以快速的获取<br>修改某个控制器中的数据，或者调用这个控制器中的方法。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"AppController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div-a"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过以下的方法，来获取控制器实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = angular.element(<span class="built_in">document</span>.getElementById(<span class="string">'div-a'</span>)).scope();</span><br></pre></td></tr></table></figure><p>接着，便可以通过这个 <code>instance</code> 来调用控制器的方法，获取和修改值了。无法是元素本身绑定有控制器，还是元素的父级元素绑定有控制器，都可以成功的获取。</p><p>茴字有很多写法，具体写的时候用哪种，完全看情况和心情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AngularJS 本身已经提供了像指令 Directive 和 服务 Service 一类的方式，来实现数据和代码的共享和复用，但在实际的项目开发中，或许是处于懒惰，亦或是为了便利，总会想在两个控制器之间，直接进行数据的共享&lt;br&gt;通信，或者是函数与方法的调用，这里我们就
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://chensd.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angular应用中的登录与身份验证</title>
    <link href="http://chensd.com/2016-07/Authorzation-and-Login-in-Angular.html"/>
    <id>http://chensd.com/2016-07/Authorzation-and-Login-in-Angular.html</id>
    <published>2016-07-09T23:34:34.000Z</published>
    <updated>2021-03-10T23:07:38.713Z</updated>
    
    <content type="html"><![CDATA[<p>Angular 经常会被用到后台和管理工具的开发，这两类都会需要对用户进行鉴权。而鉴权的第一步，就是进行身份验证。由于 Angular 是单页应用，会在一开始，就把大部分的资源加载到浏览器中，所以就更需要注意验证的时机，并保证只有通过了验证的用户才能看到对应的界面。</p><!-- __提示__：阅读本篇文章需要对 Angular 有基本的了解。 --><h2 id="功能边界"><a href="#功能边界" class="headerlink" title="功能边界"></a>功能边界</h2><p>本篇文章中的身份验证，指的是如何确定用户是否已经登录，并确保在每次与服务器的通信中，都能够满足服务器的验证需求。注意，并不包括对具体是否具有某一个权限的判断。</p><p>对于登录，主要是接受用户的用户名密码输入，提交到服务器进行验证，处理验证响应，在浏览器端构建身份验证数据。</p><h2 id="实现身份验证的两种方式"><a href="#实现身份验证的两种方式" class="headerlink" title="实现身份验证的两种方式"></a>实现身份验证的两种方式</h2><p>目前，实现身份验证的方法，主要有两个大类：</p><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>传统的浏览器网页，都是使用 Cookies 来验证身份，实际上，浏览器端的应用层里，基本不用去管身份验证的事情，Cookies 的设置，由服务器端完成，在提交请求的时候，由浏览器自动附加对应的 Cookies 信息，所以在 JavaScript 代码中，不需要为此编写专门的代码。但每次请求的时候，都会带上全部的 Cookies 数据，</p><p>随着 CDN 的应用，移动端的逐渐兴起， Cookies 越来越不能满足复杂的、多域名下的身份验证需求。</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>实际上基于密钥的身份验证并不是最近才兴起，它一直存在，甚至比 Cookies 历史更长。当浏览器在请求服务器的时候，将密钥以特定的方式附加在请求中，比如放在请求的头部（ headers ）。为此，需要编写专门的客户端代码来管理。</p><p>最近出现的基于 JSON 的 Web 密钥（JSON Web Token）标准，便是典型的使用密钥来实现的身份验证。</p><p>在 Web 应用中，如果是构造 API ，则应优先考试使用密钥方式。</p><h2 id="处理登录"><a href="#处理登录" class="headerlink" title="处理登录"></a>处理登录</h2><p>登录是身份验证第一步，通过登录，才能够组织起来对应的身份验证数据。</p><h3 id="需要使用单独的登录页吗？"><a href="#需要使用单独的登录页吗？" class="headerlink" title="需要使用单独的登录页吗？"></a>需要使用单独的登录页吗？</h3><p>登录页的处理，有两种方式：</p><ul><li><strong>单独的登录页</strong>，在登录完成后，跳转到单页应用之中，这样做可以对单页应用的资源进行访问控制，防止非登录用户访问，适合后台或者管理工具的应用场景。但实际上降低了单页应用的用户体验</li><li><strong>在单页应用之内执行登录</strong>，这样更符合单页应用的设计理念，比较适合大众产品的场景，因为恶意的人总是能够拿到你单页应用的前端代码</li></ul><h3 id="单独的登录页"><a href="#单独的登录页" class="headerlink" title="单独的登录页"></a>单独的登录页</h3><p>一般情况下，使用单独的登录页的目的在于保护登录后跳转的页面不被匿名用户访问。因此，在登录页里，构造一个表单，直接采用传统的表彰提交方式（非 Ajax），后端验证用户名密码成功后，输出登录后单面应用页面的 HTML 。</p><p>在这种情况下，可以直接将身份验证信息放在输出的 HTML 里，比如，可以使用 Jade 构造一个这样的页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- dashboard.jade --&gt;</span><br><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    link(rel=<span class="string">"stylesheet"</span>, href=<span class="string">"/assets/app.e1c2c6ea9350869264da10de799dced1.css"</span>)</span><br><span class="line">  body</span><br><span class="line">    script.</span><br><span class="line">      <span class="built_in">window</span>.token = !&#123;<span class="built_in">JSON</span>.stringify(token)&#125;;</span><br><span class="line">    div.md-padding(ui-view)</span><br><span class="line">    script(src=<span class="string">"/assets/app.84b1e53df1b4b23171da.js"</span>)</span><br></pre></td></tr></table></figure><p>后端在用户名密码验证成功之后，可以采用如下的方式来渲染输出 HTML ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res.render(<span class="string">'dashboard'</span>, &#123;</span><br><span class="line">  token: token</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Angular 应用一启动，便可以进行需要使用身份验证的通信。而且还保证了只有登录成功的用户才可以进入这个页面。</p><h3 id="单页应用内登录的组织"><a href="#单页应用内登录的组织" class="headerlink" title="单页应用内登录的组织"></a>单页应用内登录的组织</h3><p>对于多视图的 Angular 应用，一般会采用路由，在页面之内，一般有固定的侧边栏菜单，或者顶部导航菜单，正文区域由路由模块来控制。</p><p>下面的示例代码，使用的是 <a href="https://material.angularjs.org/latest/" target="_blank" rel="noopener">Angular Material</a> 来组织页面，路由模块使用的是 <a href="https://github.com/angular-ui/ui-router" target="_blank" rel="noopener">ui-router</a> 。在应用打开的时候，有专门的加载动画，加载完成之后，显示的页面，使用 <code>AppController</code> 这个控制器，对于没有登录的用户，会显示登录表单，登录完成之后，页面分为三大部分，一是顶部面包屑导航，二是侧边栏菜单，另外就是路由控制的正文部分。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">"app"</span> <span class="attr">layout</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--页面加载的提示--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">flex</span> <span class="attr">layout</span>=<span class="string">"row"</span> <span class="attr">ng-cloak</span> <span class="attr">ng-controller</span>=<span class="string">"AppController"</span> <span class="attr">ng-init</span>=<span class="string">"load()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-if</span>=<span class="string">"!isUserAuth"</span>, <span class="attr">ng-controller</span>=<span class="string">"LoginController"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--登录表单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-if</span>=<span class="string">"isUserAuth"</span> <span class="attr">flex</span> <span class="attr">layout</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">md-sidenav</span> <span class="attr">flex</span>=<span class="string">"15"</span> <span class="attr">md-is-locked-open</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"stop-text-select bbmd-sidebar md-whiteframe-4dp"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--侧边栏菜单--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">md-sidenav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">md-content</span> <span class="attr">flex</span> <span class="attr">layout</span>=<span class="string">"column"</span> <span class="attr">role</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">md-toolbar</span> <span class="attr">class</span>=<span class="string">"stop-text-select md-whiteframe-glow-z1"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--顶部菜单--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">md-toolbar</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">md-content</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--路由--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"md-padding"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">md-content</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">md-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 Loading 动画，是在 <code>AppController</code> 之外的，可以在 <code>AppController</code> 的代码中，对其进行隐藏。这样达到了所有 CSS / JavaScript 加载完成之后 Loading 就消失的目的。</p><p><code>AppController</code> 中有一个变量 <code>isUserAuth</code> ，初始化的时候是 <code>false</code> ，当本地存储的会话信息验证有效，或者登录完成之后，这个值便会置为 <code>ture</code> ，由于 <code>ng-if</code> 的控制，便可以实现隐藏登录表单、显示应用内容的目的。要注意，这里只有使用 <code>ng-if</code> 而不是 <code>ng-show/ng-hide</code> ，前者才会真正的删除和增加 DOM 元素，而后者只是修改某个 DOM 元素的 CSS 属性，这点很重要，只有这样，才能够保证登录完成之后，再加载单页应用中的内容，防止还没有登录，当前路由中的控制器代码就直接执行了。</p><h3 id="为什么客户端也要加密密码"><a href="#为什么客户端也要加密密码" class="headerlink" title="为什么客户端也要加密密码"></a>为什么客户端也要加密密码</h3><p>一个比较理想的基于用户名和密码的登录流程是这样的：</p><ul><li>浏览器端获取用户输入的密码，使用 MD5 一类的哈希算法，生成固定长度的新密码，如 <code>md5(username + md5(md5(password)))</code> ，再将密码哈希值和用户名提交给后端</li><li>后端根据用户名获取对应的盐，使用用户名和密码哈希值，算出一个密文，根据用户名和密文去数据库查询</li><li>如果查询成功，则生成密钥，返回给浏览器，并执行第 4 步</li><li>后端生成新的盐，根据新的盐和浏览器提交的密码哈希值，生成新的密文。在数据库中更新盐和密文</li></ul><p>可能有 80% 的人无法理解为什么要把一个登录做得这么复杂。这可能要写一篇专门的文章才解释得清楚。在这里先解释一下为什么浏览器端要对密码做哈希，原因如下：</p><ul><li>从源头上保护用户的密码，保证只有做按键记录才可以拿到用户的原始密码</li><li>就算网络被窃听，又没有使用 https ，那么被偷走的密码，也只是哈希之后的，最多影响用户在这个服务器里的数据，而不影响使用相同密码的其它网站</li><li>就算是服务器的所有者，都无法获取用户的原始密码</li></ul><p>这种做法，使得用户的最大风险，也只是当前这个应用中的数据被窃取。不会扩大损失范围，绝不会出现 CSDN 之流的问题。</p><h3 id="登录成功的通知"><a href="#登录成功的通知" class="headerlink" title="登录成功的通知"></a>登录成功的通知</h3><p>对于有些应用，并不是所有的页面都需要用户登录的，可能是进行某些操作的时候，才需要登录。在这种情况下，登录完成之后，必须要通知整个应用。这可以使用广播这个功能。</p><p>简易代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .controller(<span class="string">'LoginController'</span>, [<span class="string">'$rootScope'</span>, LoginController]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginController</span>(<span class="params">$rootScope</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 登录成功之后调用的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">afterLoginSuccess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $rootScope.$broadcast(<span class="string">'user.login.success'</span>, &#123;</span><br><span class="line">      <span class="comment">// 需要传输的数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其它的控制器中，便可以监听这个广播，并执行登录成功之后需要进行的操作，如获取列表或者详情：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(<span class="string">'user.login.success'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">handle, data</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="身份验证信息"><a href="#身份验证信息" class="headerlink" title="身份验证信息"></a>身份验证信息</h2><p>登录成功之后，服务器返回了密钥，之后的 API 请求都需要带上密钥，而且请求返回的响应，还需要检查是否是关于身份信息失效的错误。这一系列的工作比较繁琐，应该是自动完成才行。</p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>密钥的保存，大概有如下几个办法：</p><ul><li><strong>Cookies</strong>：前面已经提到了，这个并不推荐使用。同时，它还有最大 4k 的限制</li><li><strong>sessionStorage</strong>：tab 页内有效，一旦关闭，或者打开了新的 tab 页，sessionStorage 是不能共享的</li><li><strong>localStorage</strong>：较为理想的存储方式，除非清理浏览器数据，否则 localStorage 存储的数据会一直存在</li><li><strong>Angular 单例 Service</strong>：存储在应用之内得话，刷新后数据会丢失，当然也不能 tab 页之间共享</li></ul><p>比较好的办法是，身份验证信息存储在 localStorage 里，但在应用启动时，初始化到 Angular 的单例 Service 中。</p><h3 id="在请求中加入身份验证信息"><a href="#在请求中加入身份验证信息" class="headerlink" title="在请求中加入身份验证信息"></a>在请求中加入身份验证信息</h3><p>身份验证信息的目的，是为了向服务器表明身份，获取数据。所以，在请求中需要附加身份验证信息。</p><p>一般的应用中，身份验证信息都是放在请求的 headers 头部中。如果在每次请求的时候，一一设置 headers ，那就太费时费力了。Angular 中的 <code>$httpProvider</code> 提供了一个拦截器 <code>interceptors</code> ，通过它可以实现对每一个请求和响应的统一处理。添加拦截器的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .config([<span class="string">'$httpProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$httpProvider</span>)</span>&#123;</span><br><span class="line">    $httpProvider.interceptors.push(HttpInterceptor);</span><br><span class="line">  &#125;]);</span><br></pre></td></tr></table></figure><p><code>HttpInterceptor</code> 的定义方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">angular</span><br><span class="line">  .module(<span class="string">'app'</span>)</span><br><span class="line">  .factory(<span class="string">'HttpInterceptor'</span>, [<span class="string">'$q'</span>, HttpInterceptor]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HttpInterceptor</span>(<span class="params">$q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 请求发出之前，可以用于添加各种身份验证信息</span></span><br><span class="line">    request: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(localStorage.token) &#123;</span><br><span class="line">        config.headers.token = localStorage.token;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 请求发出时出错</span></span><br><span class="line">    requestError: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> $q.reject(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 成功返回了响应</span></span><br><span class="line">    response: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回的响应出错，包括后端返回响应时，设置了非 200 的 http 状态码</span></span><br><span class="line">    responseError: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> $q.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器提供了对发出请求到返回响应的全生命周期处理，一般可以用来做下面几个事情：</p><ul><li>统一在发出的请求中添加数据，如添加身份验证信息</li><li>统一处理错误，包括请求发出时出的错（如浏览器端的网络不通），还有响应时返回的错误</li><li>统一处理响应，比如缓存一些数据等</li><li>显示请求进度条</li></ul><p>在上面的示例代码中，当 localStorage 中包括 <code>token</code> 这个值时，就在每一个请求的头部，添加一个 <code>token</code> 值。</p><h3 id="失效及处理"><a href="#失效及处理" class="headerlink" title="失效及处理"></a>失效及处理</h3><p>一般的，后端应该在 <code>token</code> 验证失败时，将响应的 http 状态码设置为 401 ，这样，在拦截器的 <code>responseError</code> 中便可以统一处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">responseError: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span> === err.status) &#123;</span><br><span class="line">    <span class="comment">// 远程服务器无响应</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">401</span> === err.status) &#123;</span><br><span class="line">    <span class="comment">// 401 错误一般是用于身份验证失败，具体要看后端对身份验证失败时抛出的错误</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">404</span> === err.status) &#123;</span><br><span class="line">    <span class="comment">// 服务器返回了 404</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $q.reject(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，只要服务器返回的状态码不是 200 ，都会调用 <code>responseError</code> ，可以在这里，统一处理并显示错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Angular 经常会被用到后台和管理工具的开发，这两类都会需要对用户进行鉴权。而鉴权的第一步，就是进行身份验证。由于 Angular 是单页应用，会在一开始，就把大部分的资源加载到浏览器中，所以就更需要注意验证的时机，并保证只有通过了验证的用户才能看到对应的界面。&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://chensd.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用原生 JavaScript 获取文本的行数</title>
    <link href="http://chensd.com/2016-06/Pure-js-get-line-count-of-html-element.html"/>
    <id>http://chensd.com/2016-06/Pure-js-get-line-count-of-html-element.html</id>
    <published>2016-06-24T22:52:48.000Z</published>
    <updated>2021-03-10T23:07:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发中会有这样的需求：只显示两行，如果超过两行，则显示一个“显示更多”的按钮，点击按钮来显示剩余行的内容。有个 jQuery 的插件 <a href="https://github.com/midudev/loadingDots" target="_blank" rel="noopener">loadingDots</a> 专门实现了这个功能。不过这里我们来看看如何利用原生的 JavaScript 来实现。要实现这个需求，最关键的是要确定这个容器内文本的行数，得到行数后，修改元素高度，并确定是否显示加载按钮。</p><h2 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle()"></a>window.getComputedStyle()</h2><p>要使用原生 JavaScript 代码获取一个元素的各个 style 属性，使用 <code>window.getComputedStyle()</code> 是必然的。它可以返回一个 HTML 元素在浏览器中真正显示时的各个样式——当然，有些样式会被浏览器给屏蔽，比如，你要获取一个链接的颜色，并准备通过颜色来判断用户是否访问过某个地址，那肯定是不行的。</p><p>该方法返回的，是一个样式键值对，是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration" target="_blank" rel="noopener">CSSStyleDeclaration</a> 的实例。各属性索引名没有 <code>-</code> ，且采用驼峰命名法。比如 <code>lineHeight</code> 。</p><h2 id="行数-整体高度-行高"><a href="#行数-整体高度-行高" class="headerlink" title="行数 = 整体高度 / 行高"></a>行数 = 整体高度 / 行高</h2><p>整体高度通过 <code>height</code> 可以获取。行高可以通过 <code>lineHeight</code> 获取，将其结果再取整即可得到行数。</p><p>但有个问题，如果没有针对一个元素设置 <code>line-height</code> 值，则其默认值为 <code>normal</code> ，这个值在桌面浏览器中通常是 1.2 ，但还与字体有关。因此，最好是对需要计算行数的元素设置一下 <code>line-height</code> 值。</p><p>一个简单的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countLines</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> styles = <span class="built_in">window</span>.getComputedStyle(ele, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> lh = <span class="built_in">parseInt</span>(styles.lineHeight, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> h = <span class="built_in">parseInt</span>(styles.height, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> lc = <span class="built_in">Math</span>.round(h / lh);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'line count:'</span>, lc, <span class="string">'line-height:'</span>, lh, <span class="string">'height:'</span>, h);</span><br><span class="line">  <span class="keyword">return</span> lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>请参见 <a href="http://chensd.com/code/lineCount.html">Demo</a> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际开发中会有这样的需求：只显示两行，如果超过两行，则显示一个“显示更多”的按钮，点击按钮来显示剩余行的内容。有个 jQuery 的插件 &lt;a href=&quot;https://github.com/midudev/loadingDots&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="随手记" scheme="http://chensd.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://chensd.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 主题开发指南</title>
    <link href="http://chensd.com/2016-06/hexo-theme-guide.html"/>
    <id>http://chensd.com/2016-06/hexo-theme-guide.html</id>
    <published>2016-06-19T07:17:53.000Z</published>
    <updated>2021-03-10T23:07:38.727Z</updated>
    
    <content type="html"><![CDATA[<p>当你看到你用的主题出现在两个以上的博客的时候，那你就要考虑自己写一个了。本文的主角是 Hexo ，如果你没有用过，那可以考虑 <a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">Hexo 你的博客</a> 了，如果你还没有写博客，那你真的<a href="https://www.google.com/#q=%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2" target="_blank" rel="noopener">该试试了</a>。根据<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">阮一峰提出的博客三阶段</a>，技术人员早晚会选择 Github Pages 类似的服务，而 Hexo 绝对是值得尝试的。</p><h2 id="本文内容与目的"><a href="#本文内容与目的" class="headerlink" title="本文内容与目的"></a>本文内容与目的</h2><p>写这篇文章的目的，当然是希望帮你快速的制作一款主题，将要包含的内容如下：</p><ul><li>主题的基本结构</li><li>常见问题</li><li>常用页面的实现</li><li>基本工具</li></ul><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>写这篇文章的原因，就是因为制作了一个主题 <a href="http://chensd.com/2016-05/hexo-theme-random.html">Random</a>（<a href="https://github.com/stiekel/hexo-theme-random" target="_blank" rel="noopener">代码</a>、<a href="http://random-stiekel.rhcloud.com/" target="_blank" rel="noopener">Demo</a>），大家可以先看看，下面的代码，大都来自于这个主题。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>制作 Hexo 主题，除了需要了解 HTML / CSS / JavaScript 之外，还需要了解两个主要的技术，首先一个是模板引擎，Hexo支持主流的模板引擎，像 EJS / Jade / Swig 等，另外一个是 CSS 预处理，如 SASS / LESS / Stylus ，当然，这两个不用，直接使用 HTML / CSS 也是可以的，只不过可能效率会低一点，在本文中，选择使用如下两个：</p><ul><li>Stylus：<a href="http://stylus-lang.com/" target="_blank" rel="noopener">语法文档</a>，选择它，纯粹是因为想熟悉一下新技术</li><li>Swig：<a href="http://paularmstrong.github.io/swig/" target="_blank" rel="noopener">语法文档</a>，这个项目的作者已经半放弃了该项目，你也可以考虑使用 <del>Jade</del> <a href="http://jade-lang.com/tutorial/" target="_blank" rel="noopener">Pug</a> ，两个功能差距不大，选择这个的原因同上</li></ul><p>这篇文章将不介绍它们的使用，请参考它们的文档。</p><h2 id="Hexo-工作流程"><a href="#Hexo-工作流程" class="headerlink" title="Hexo 工作流程"></a>Hexo 工作流程</h2><p>如果你已经看到了这篇文章，基本上你已经是一个 Hexo 用户了，但还是简单的介绍一下 Hexo 的流程：</p><ul><li>使用 <code>hexo init</code> 来生成基本文件，做一些基本的配置，像安装模块、配置主题等</li><li>使用 <code>hexo new page / post</code>来生成文章或页面的 md 文件，编辑</li><li>使用 <code>hexo g</code> 生成文件，Hexo 会根据主题中的模板，来生成对应的 html 文件，转译 CSS 文件，复制其它的静态文件（如图片图标字体等），组织为一个静态网站</li><li>使用 <code>hexo d</code> 来部署，一般是借助一些<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">部署模块</a>完成</li></ul><p>主题的作用就是在 Hexo 生成文件的时候，提供对应的模板和资源。</p><h2 id="主题的基本结构"><a href="#主题的基本结构" class="headerlink" title="主题的基本结构"></a>主题的基本结构</h2><p>Hexo 对主题的基本要求，是需要有如下几个页面：</p><ul><li>首页 <code>index</code></li><li>存档页 <code>archive</code></li><li>标签文章列表页 <code>tag</code></li><li>分类文章列表页 <code>category</code></li><li>文章详情页 <code>post</code></li><li>页面详情页 <code>page</code></li></ul><p>以上这些文件，是 Hexo 在生成 HTML 文件时要用到的，全部放在主题的<code>layout</code>文件夹中。由于上面这些页面里，有很多代码是重复的，比如，HTML文件的 head 部分，页面的顶部导航，底部版权部分等，为了修改方便，组织简洁，一般会将可重用的部分提出来，再利用模板引擎来引入。</p><p>此外，还有些 JS / CSS / 图片/ favicon.ico 一类的文件，这类文件并不需要 Hexo 进行转换，直接就在 HTML 页面里引用了，所以全部放在主题的<code>source</code> 文件夹中。</p><h2 id="使用-yeoman-生成基础代码"><a href="#使用-yeoman-生成基础代码" class="headerlink" title="使用 yeoman 生成基础代码"></a>使用 yeoman 生成基础代码</h2><p>现在开始项目之前，我都会搜索一下 yeoman 有没有库，生成 Hexo 主题就有 <a href="https://github.com/tcrowe/generator-hexo-theme" target="_blank" rel="noopener">generator-hexo-theme</a> 。如果还没有安装 yeoman ，那先用 npm 全局安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yo</span><br></pre></td></tr></table></figure><p>接着安装生成器的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g generator-hexo-theme</span><br></pre></td></tr></table></figure><p>然后到自己的博客目录之下，进入到 <code>themes</code> 目录，创建一个用主题名命名的新文件夹，比如<code>test</code>，进入新文件夹，先设置一下目录的权限，否则 yeoman 会提示权限不足：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 675 ./</span><br></pre></td></tr></table></figure><p>运行这个命令一般需要管理员权限，请根据自己系统的情况加<code>su</code> / <code>sudo</code>。接着开始生成代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo hexo-theme</span><br></pre></td></tr></table></figure><p>然后选择一些基本的配置，比如使用什么模板引擎，使用什么 CSS 预编译等，这里分别选择 Swig 和 Stylus。完成之后，主题目录下就会生成一些如下结构的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml // 主题配置文件</span><br><span class="line">├── languages // 多语言文件夹</span><br><span class="line">├── layout</span><br><span class="line">│   ├── archive.swig // 存档页模板</span><br><span class="line">│   ├── category.swig // 分类文章列表页模板</span><br><span class="line">│   ├── includes // 各页面共享的模板</span><br><span class="line">│   │   ├── layout.swig // 页面布局模板，其它的页面模板都是根据它扩展来的</span><br><span class="line">│   │   ├── pagination.swig // 翻页按钮模板</span><br><span class="line">│   │   └── recent-posts.swig // 文章列表模板</span><br><span class="line">│   ├── index.swig // 首页模板</span><br><span class="line">│   ├── page.swig // 页面详情页模板</span><br><span class="line">│   ├── post.swig // 文章详情页模板</span><br><span class="line">│   └── tag.swig // 标签文章列表页模板</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── css</span><br><span class="line">    │   └── theme.styl // 主题自定义 CSS 文件</span><br><span class="line">    ├── favicon.ico</span><br><span class="line">    └── js</span><br><span class="line">        └── theme.js // 主题 JavaScript 文件</span><br></pre></td></tr></table></figure><p>赶紧在 Hexo 的主配置文件中使用新主题，到博客根目录下找到 <code>_config.yml</code> 文件，找到<code>theme</code>行，修改如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: test</span><br></pre></td></tr></table></figure><p>赶紧 <code>hexo s</code> 启动博客，到浏览器看看效果吧。</p><h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p>Hexo 支持多语言显示，在主题的 <code>languages</code> 文件夹中，存放具体的多语言文件，可以是 YML 或者 JSON 文件。再在主配置文件 <code>_config.yml</code> 中使用下面的方法来指定具体的使用的配置文件名：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br><span class="line"># 或者多个配置文件</span><br><span class="line">language:</span><br><span class="line"> - zh-CN</span><br><span class="line"> - en</span><br></pre></td></tr></table></figure><p>像下面这样组织语言文件，<code>languages/en.yml</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">archive_title: Archives</span><br><span class="line">category_title: Category</span><br><span class="line">tag_title: Tag</span><br></pre></td></tr></table></figure><p>在模板里，当需要在页面中显示文字时，可以使用 Hexo 提供的帮助函数 <code>__()</code> / <code>_p()</code> 来读取具体的值，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> is_archive() %&#125;</span><br><span class="line">  &#123;% <span class="keyword">set</span> pageTitle = _p('archive_title') %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;h1&gt;&#123;&#123; page_title &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure><p>这样，主题就可以轻松支持使用不同语言的博客主。</p><h2 id="各个页面的布局"><a href="#各个页面的布局" class="headerlink" title="各个页面的布局"></a>各个页面的布局</h2><p>在上面生成的代码中，所有页面均使用同一个布局，全部扩展自 <code>includes/layout.swig</code> ，在这个文件中，可以看到第 51 行有如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block body %&#125;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>在其它的布局文件（除开 <code>includes</code> 目录中的）里，都是使对 <code>includes/layout.swig</code> 进行扩展，然后指定 <code>body</code> 这个块的代码，比如像 <code>index.swig</code> 的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends <span class="string">'includes/layout.swig'</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">  &#123;% include <span class="string">'includes/recent-posts.swig'</span> %&#125;</span><br><span class="line">  &#123;% include <span class="string">'includes/pagination.swig'</span> %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>这就相当于是使用 <code>includes/layout.swig</code> 里的代码，并且将 <code>block body</code> 替换为那两行代码。注意，这个功能， EJS 模板引擎是不支持的。</p><p>因此，如果你要不同页面使用不同的布局，那就需要你在各自的页面里自定义，或者在单独的布局文件中定义，再扩展。</p><h2 id="数据的填充"><a href="#数据的填充" class="headerlink" title="数据的填充"></a>数据的填充</h2><p>主题是供了页面的布局和样式，在生成 HTML 文件时，Hexo 会把特定的数据，传给 swig 模板，然后再由 swig 将数据填充到 HTML 文件之中。这些特定的数据，分为如下几类。</p><h3 id="主配置文件数据"><a href="#主配置文件数据" class="headerlink" title="主配置文件数据"></a>主配置文件数据</h3><p>Hexo 的根目录中，有个 <code>_config.yml</code> 文件，它就是主配置文件，数据组织使用 <a href="http://docs.ansible.com/ansible/YAMLSyntax.html" target="_blank" rel="noopener">yml语法</a>，其中的项目，可以在模板中直接使用，比如博客的名字、副标题等等之类。这些数据项组织在 <code>config</code> 对象中。可以数字、字符串、对象、数组，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 字符串</span><br><span class="line">title: 不可能不确定</span><br><span class="line"># 没有值</span><br><span class="line">permalink_defaults:</span><br><span class="line"># 逻辑值</span><br><span class="line">auto_spacing: true</span><br><span class="line"># 数字</span><br><span class="line">since: 2010</span><br><span class="line"># 数组</span><br><span class="line">skip_render: </span><br><span class="line">  - "books"</span><br><span class="line">  - "books/*"</span><br><span class="line"># 对象</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/stiekel</span><br><span class="line">  Coding.NET: https://coding.net/u/Stiekel</span><br><span class="line">  Twitter: https://twitter.com/SidCN</span><br></pre></td></tr></table></figure><p>完整代码，请参见<a href="https://github.com/stiekel/blog/blob/master/_config.yml" target="_blank" rel="noopener">_config.yml</a>。</p><h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>每个主题，还有单独的配置文件，用于配置与主题紧密相关的内容，格式与主配置文件一致。只不过变量名为 <code>theme</code>。</p><p>具体哪些数据放到主配置文件中，哪些数据放到主题配置文件，自由度其实很高，一般的，推荐与博客中的数据相关的，放主配置文件，如博客的名字、作者、菜单配置等，与主题相关的，放到主题配置文件，比如主题的脚本文件列表、样式文件列表等。当然，在编写主题的时候，也可以考虑对于某一个数据，既可以放在主配置文件中，也可以放在主题配置文件中，像这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set menu = config.menu || theme.menu %&#125;</span><br></pre></td></tr></table></figure><p>要读取菜单配置时，任意哪个配置文件中有都可以，而且是优先使用主配置文件中的配置。</p><h3 id="配置文件中数据的使用"><a href="#配置文件中数据的使用" class="headerlink" title="配置文件中数据的使用"></a>配置文件中数据的使用</h3><p>如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件 swig 中直接使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"title"</span> onClick=<span class="string">"openUserCard()"</span>&gt;&#123;&#123; config.title &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>这就相当于把配置文件中的 <code>title</code> 输出到 HTML 中。如果是要遍历数组或者对象，就要复杂一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"index-nav-link"</span>&gt;</span><br><span class="line">  &#123;% <span class="keyword">set</span> menu = config.menu || theme.menu %&#125;</span><br><span class="line">  &#123;% <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(menu)  %&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> menu[key] != <span class="string">'/'</span>  %&#125;</span><br><span class="line">      &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(menu[key]) &#125;&#125;"</span>&gt;</span>&#123;&#123; key &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">  &#123;% endfor %&#125;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p><code>Object.keys</code> 是取出一个对象的所有索引，<code>for key in</code>是遍历索引数组，即将对象的所有值生成一组用 <code>&lt;li&gt;&lt;/li&gt;</code> 组织的链接。</p><h2 id="常用功能的实现"><a href="#常用功能的实现" class="headerlink" title="常用功能的实现"></a>常用功能的实现</h2><p>Hexo 提供了很多专门的变量及函数，用于在编写主题时使用。请参见<a href="https://hexo.io/docs/variables.html" target="_blank" rel="noopener">变量列表</a>和<a href="https://hexo.io/docs/helpers.html" target="_blank" rel="noopener">帮助函数列表</a>。这里针对常用的一些功能做对应的介绍。</p><h3 id="获取站点的所有的文章、页面、标签和分类"><a href="#获取站点的所有的文章、页面、标签和分类" class="headerlink" title="获取站点的所有的文章、页面、标签和分类"></a>获取站点的所有的文章、页面、标签和分类</h3><p>Hexo 为主题提供了一个变量 <code>site</code> ，这个变量包括以下几个成员：</p><ul><li><code>site.posts</code> 博客里的所有文章列表</li><li><code>site.pages</code> 所有创建的页面的列表</li><li><code>site.categories</code> 分类列表</li><li><code>site.tags</code> 标签列表</li></ul><p>其中，<code>site.posts</code>与<code>site.pages</code>两个结构是相同的，它们各自包括两个成员，一个 length 为长度，一个 data 为具体的数组，它是个对象，但索引是数组，成员是各个文章的详情。</p><p><code>site.categories</code>和<code>site.tags</code>则为两个对象，成员比较多，但具体的分类和标签列表，存在索引为<code>data</code>的成员上，该成员为对象，对象的索引为分类和标签对应的 <code>id</code>，类似于：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"data":&#123;</span><br><span class="line">  "cipap3lwj0001fhpvlubaa0sp":&#123;</span><br><span class="line">    "name":"乱七八糟",</span><br><span class="line">    "_id":"cipap3lwj0001fhpvlubaa0sp"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过实际在编写主题的时候，很少会直接用到这几个变量。</p><h3 id="获取当前页面的数据"><a href="#获取当前页面的数据" class="headerlink" title="获取当前页面的数据"></a>获取当前页面的数据</h3><p>这个变量便是 <code>page</code> ，这个变量的特点是，在不同的页面中，它的成员会不一样。比如，在文章归档页，它就有文章列表，如果在文章详情页，它就包含有文章的相关信息。而且在不同的页面中，就算同一个索引的成员，值也会不一样，比如 <code>page.posts</code>，在首页，它是按分页设置限制过的文章列表，而在存档页则是所有文章的列表。</p><p>比如，在我们生成的代码中，首页里使用 <code>includes/recent-posts.swig</code> （<a href="https://github.com/stiekel/hexo-theme-random/blob/master/layout/includes/recent-posts.swig" target="_blank" rel="noopener">在线代码</a>）来显示文章列表，其主要代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> site.posts.length &gt; <span class="number">0</span> %&#125;</span><br><span class="line">    &#123;# ... #&#125;</span><br><span class="line">    &#123;% <span class="keyword">for</span> postItem <span class="keyword">in</span> site.posts.toArray() %&#125;</span><br><span class="line">      &#123;# ... #&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>如果你的博客已经有几篇文章得话，会发现文章虽然列出来了，但并不是按时间来排列的。所以几乎没什么用，但如果使用 <code>page.posts</code> 变量替代 <code>site.posts</code>，结果就不一样了，修改一下试试。</p><p>再刷新一下首页，可以看到，文章只有几篇，并不是全部文章，且按时间倒序排列。<code>page</code> 的所有成员，请参见<a href="https://hexo.io/docs/variables.html#Page-Variables" target="_blank" rel="noopener">列表</a>。</p><h3 id="各种链接的处理"><a href="#各种链接的处理" class="headerlink" title="各种链接的处理"></a>各种链接的处理</h3><p>获取某个页面的地址，有很多方法。包括：</p><ul><li>全局的变量 <code>path</code> <code>url</code></li><li><code>page.path</code> <code>page.permalink</code>，这两个值在单个的文章、分类和标签中，也是都有的</li></ul><p>我们来看看这几个值各自有何作用。打开 <code>layout/post.swig</code> ，在第4行前插入如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; path | json &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&#123;&#123; url | json &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; page.path | json &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&#123;&#123; page.permalink | json &#125;&#125;&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure><p>然后启动博客，进入做任意一篇文章，可以在顶部看到三个字符串，类似于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"2016-06/Material-Design-Float-Action-Button.html"</span><br><span class="line">"http://chensd.com/2016-06/Material-Design-Float-Action-Button.html"</span><br><span class="line">"2016-06/Material-Design-Float-Action-Button.html"</span><br><span class="line">"http://chensd.com/2016-06/Material-Design-Float-Action-Button.html"</span><br></pre></td></tr></table></figure><p>链接的具体样式，是主配置文件中 <code>permalink</code> 来决定的，这里的配置值为<code>:year-:month/:title.html</code>。可以看出来，<code>path</code> 与 <code>page.path</code> 输出一致，<code>url</code> 与 <code>page.permalink</code> 一致。而这几个链接都是无法直接使用的。因为 <code>page.path</code> 的值是相对路径，所以除了首页都是不能直接当链接的。而 <code>path.permalink</code> ，则是带有主配置文件中 <code>url</code> 值配置的全路径，也不太好当作站内链接直接使用。这时候，就需要 Hexo 提供的帮助函数 <code>url_for()</code> 来救场了。</p><p>再来加一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; url_for(page.path) | json &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"/2016-06/Material-Design-Float-Action-Button.html"</span><br></pre></td></tr></table></figure><p>这个结果就比较适合作为站内链接了。</p><h3 id="在页面中加入-css-与-js-文件"><a href="#在页面中加入-css-与-js-文件" class="headerlink" title="在页面中加入 css 与 js 文件"></a>在页面中加入 css 与 js 文件</h3><p>Hexo 提供了两个帮助函数 <code>css()</code> 和 <code>js()</code> ，传入路径数组便可生成对应的 <code>link</code> / <code>script</code> 标签。路径数组配置在主题的配置文件中。</p><h3 id="当前页面类型的判断"><a href="#当前页面类型的判断" class="headerlink" title="当前页面类型的判断"></a>当前页面类型的判断</h3><p>由于有些代码在不同的页面都是共用的，所以有时候就需要根据不同的页面，做不同的显示。比如，一般会把 HTML 的 <code>&lt;head&gt;&lt;/head&gt;</code> 部分写到一个单独的文件里。比如，这里生成的 <code>layout/includes/layout.swig</code> 文件里，就需要根据不同的页面，来生成不同的 <code>&lt;title&gt;&lt;/title&gt;</code> 标签值。<a href="https://hexo.io/docs/helpers.html#Conditional-Tags" target="_blank" rel="noopener">这类判断的方法</a>主要有：</p><ul><li><code>is_tag()</code></li><li><code>is_category()</code></li><li><code>is_month()</code> 存档页中的按月份文章列表页</li><li><code>is_year()</code> 存档页中的按年份文章列表页</li><li><code>is_archive()</code></li><li><code>is_post()</code></li><li><code>is_home()</code></li><li><code>is_current()</code> 传入一个 URL ，判断是否本页就是，比如，链接中要对当前页面的链接做加强显示，就可以利用这个方法来添加对应的 class</li></ul><h3 id="常用的字符串处理函数"><a href="#常用的字符串处理函数" class="headerlink" title="常用的字符串处理函数"></a>常用的字符串处理函数</h3><ul><li><code>strip_html()</code> 去除一段 HTML 代码中的标签，返回其包含的字符</li><li><code>markdown()</code> 将 md 代码转换为 HTML</li><li><code>word_wrap()</code> 将一段字符，按固定宽度插入换行符号</li><li><code>truncate()</code> 按固定长度截取字符串，比如，生成摘要时，如果没有摘要，可以截取一段文本</li></ul><p>另外几个，请参见<a href="https://hexo.io/docs/helpers.html#String-Manipulation" target="_blank" rel="noopener">字符串处理函数</a>列表。</p><h3 id="时间的处理"><a href="#时间的处理" class="headerlink" title="时间的处理"></a>时间的处理</h3><p>Hexo 提供了多个<a href="https://hexo.io/docs/helpers.html#Date-amp-Time" target="_blank" rel="noopener">时间处理函数</a>，不过一个 <code>date()</code> 也就够用了，接受两个参数，第一个为时间值，第二个为格式，模板引用中用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">set</span> thisYear = date(Date.now(), 'YYYY') %&#125;</span><br></pre></td></tr></table></figure><p>HTML 中用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span> = <span class="string">"post-title-date"</span>&gt;</span>&#123;&#123; date(postItem.date, 'M-D') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于是使用 Moment.js 来显示的时间，所以直接使用 Moment.js 的<a href="http://momentjs.com/docs/#/displaying/" target="_blank" rel="noopener">时间格式</a>就行了，常用的如下：</p><ul><li><code>YYYY-MM-DD</code> =&gt; 2016-06-17</li><li><code>M-D</code> =&gt; 6-17</li><li><code>HH:mm:SS</code> =&gt; 07:38:19</li></ul><h3 id="生成标签云"><a href="#生成标签云" class="headerlink" title="生成标签云"></a>生成标签云</h3><p>Hexo 提供了帮助函数<code>tagcloud()</code>来生成标签云。生成的时候，可以设定标签云的文字大小范围、排序、颜色等值。具体请参见<a href="https://hexo.io/docs/helpers.html#tagcloud" target="_blank" rel="noopener">参数列表</a>。</p><p>以下是生成的一个标签云 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tag-cloud-tags"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/tags/ASP-NET/"</span> <span class="attr">style</span>=<span class="string">"font-size: 17.33px; color: #929292"</span>&gt;</span>ASP.NET<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/tags/Access/"</span> <span class="attr">style</span>=<span class="string">"font-size: 24px; color: #6f6f6f"</span>&gt;</span>Access<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/tags/Android/"</span> <span class="attr">style</span>=<span class="string">"font-size: 17.33px; color: #929292"</span>&gt;</span>Android<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样便可以通知设置 <code>tag-cloud-tags</code> 的样式来自定义标签云的外观。</p><h3 id="生成文章的目录"><a href="#生成文章的目录" class="headerlink" title="生成文章的目录"></a>生成文章的目录</h3><p>对于长文章，目录还是非常实用的，Hexo 也提供了 <code>toc()</code> 来实现这一功能，具体请参见<a href="https://hexo.io/docs/helpers.html#toc" target="_blank" rel="noopener">文档</a>。</p><p>生成的 HTML 是个有序列表，结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"toc"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"toc-item toc-level-3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"toc-link"</span> <span class="attr">href</span>=<span class="string">"#按钮的定位"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"toc-text"</span>&gt;</span>按钮的定位<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要使用了 <code>toc()</code> 函数，无论当前页面有几个标题，都会生成对应的代码。比如想当目录少于三个的时候自动隐藏，那就得靠 JavaScript 了。可以通过获取 <code>ol.toc</code> 子成员的数量，来确定其显示或隐藏，jQuery 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($(<span class="string">"ol.toc"</span>).children().length &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">  $(<span class="string">".toc"</span>).hide();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当目录条数少于四条时，便自动隐藏目录。</p><h2 id="页面的组织"><a href="#页面的组织" class="headerlink" title="页面的组织"></a>页面的组织</h2><h3 id="代码的复用"><a href="#代码的复用" class="headerlink" title="代码的复用"></a>代码的复用</h3><p>上面我们曾经提到，对于一个主题，主要有首页、存档页、标签文章列表页、分类文章列表页、文章详情页、页面详情页这几个页面。这些页面的实现中，你会发现有大量的代码是可以共享的，比如：</p><ul><li>HTML 的 <code>&lt;head&gt;&lt;/head&gt;</code> 部分</li><li>页面的顶部导航</li><li>页面的底部版权和链接</li><li>各个文章列表页中的单个文章的链接（一般包括文章标题、标签、分类、时间、摘要等信息）</li><li>第三方插件代码，如评论、统计等</li><li>分页按钮</li></ul><p>所以，对于这部分的代码，一般都会设计成可复用的代码段，将这些代码段文章存放在 <code>includes</code> 文件夹中，如果在某个页面中需要使用，只需要使用模板引擎的 include 功能来包含。比如，我们来看看如何组织一个文章列表中的单个文章的链接，这个代码段会在存档页、标签和分类的文章列表页等地方用到，创建文件 <code>includes/post-title-item.swig</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-title-item"</span>&gt;</span><br><span class="line">  &#123;# postItem 为存有一个文章的所有信息的对象 #&#125;</span><br><span class="line">  &#123;# postItem.title 为文章标题，如果没有标题，则直接截取文章内容 #&#125;</span><br><span class="line">  &#123;# strip_html 是将 html 代码中提取可供普通人阅读的文字部分 #&#125;</span><br><span class="line">  &#123;# trim 是去除前后空格 #&#125;</span><br><span class="line">  &#123;% <span class="keyword">set</span> postTitle = postItem.title || trim(strip_html(postItem.content))  %&#125;</span><br><span class="line">  &lt;a href="&#123;&#123; config.root &#125;&#125;&#123;&#123; postItem.path &#125;&#125;<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &#123;# 标题最多 80 个字符，超过得话，使用 truncate 来截取 #&#125;</span></span><br><span class="line"><span class="string">  &#123;% if postTitle.length &lt; 80 %&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123; postTitle &#125;&#125;</span></span><br><span class="line"><span class="string">  &#123;% else %&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123; truncate( postTitle, &#123;length: 80&#125;) &#125;&#125;</span></span><br><span class="line"><span class="string">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;p class="</span>page-title-sub<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &#123;# 显示时间 #&#125;</span></span><br><span class="line"><span class="string">    &lt;span id = "</span>post-title-date<span class="string">"&gt;&#123;&#123; date(postItem.date, 'M-D') &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &#123;% if postItem.categories.length %&#125;</span></span><br><span class="line"><span class="string">    &#123;# 组织分类的链接列表 #&#125;</span></span><br><span class="line"><span class="string">    &lt;span id = "</span>post-title-categories<span class="string">"&gt;&#123;&#123; __('category_title') &#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;% set i = 0 %&#125;</span></span><br><span class="line"><span class="string">    &#123;% for cat in postItem.categories %&#125;</span></span><br><span class="line"><span class="string">      &#123;% if i !== 0 %&#125;</span></span><br><span class="line"><span class="string">        &#123;&#123;'/'&#125;&#125;</span></span><br><span class="line"><span class="string">      &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">      &#123;% set i = i + 1 %&#125;</span></span><br><span class="line"><span class="string">      &lt;a href="</span>&#123;&#123; url_for(cat.path) &#125;&#125;<span class="string">"&gt;&#123;&#123; cat.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">    &lt;/span&gt;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">    &#123;# 组织标签的链接列表 #&#125;</span></span><br><span class="line"><span class="string">    &#123;% if postItem.tags.length %&#125;</span></span><br><span class="line"><span class="string">    &lt;span id = "</span>post-title-tags<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123; __('tag_title') &#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;% set i = 0 %&#125;</span></span><br><span class="line"><span class="string">    &#123;% for tag in postItem.tags %&#125;</span></span><br><span class="line"><span class="string">      &#123;% if i !== 0 %&#125;</span></span><br><span class="line"><span class="string">        &#123;&#123;'/'&#125;&#125;</span></span><br><span class="line"><span class="string">      &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">      &#123;% set i = i + 1 %&#125;</span></span><br><span class="line"><span class="string">      &lt;a href="</span>&#123;&#123; url_for(tag.path) &#125;&#125;<span class="string">"&gt;&#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">    &lt;/span&gt;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">    &#123;# 有些在文章的头部指定了照片，也显示出来 #&#125;</span></span><br><span class="line"><span class="string">    &#123;% if postItem.photos %&#125;</span></span><br><span class="line"><span class="string">      &lt;br&gt;</span></span><br><span class="line"><span class="string">      &#123;% set i = 0 %&#125;</span></span><br><span class="line"><span class="string">      &#123;% for photo in postItem.photos %&#125;</span></span><br><span class="line"><span class="string">        &#123;% set i = i + 1 %&#125;</span></span><br><span class="line"><span class="string">        &#123;% if i &lt;= 3 %&#125;</span></span><br><span class="line"><span class="string">          &#123;# 这里使用了 fancybox 的一些功能，具体后面了解 #&#125;</span></span><br><span class="line"><span class="string">          &lt;a class="</span>fancybox-thumb<span class="string">" rel="</span>fancybox-thumb<span class="string">" href="</span>&#123;&#123;photo&#125;&#125;<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &lt;img src="</span>&#123;&#123;photo&#125;&#125;<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">          &lt;/a&gt;</span></span><br><span class="line"><span class="string">        &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">      &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">  &lt;/p&gt;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在需要使用的页面中，单个文章对象的常量名设置为 <code>postItem</code> 便可以组织为相应的结构。比如，在标签文章列表页，可以这样组织：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;# 遍历所有文章，注意，单个文章的对象为 `postItem` #&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> postItem <span class="keyword">in</span> site.posts.toArray() %&#125;</span><br><span class="line">  &#123;% <span class="keyword">set</span> isShow = false %&#125;</span><br><span class="line">  &#123;# 确定一下某一个文章，是否包含当前这个标签 #&#125;</span><br><span class="line">  &#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> postItem.tags %&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> tag.name === page.tag %&#125;</span><br><span class="line">      &#123;% <span class="keyword">set</span> isShow = true %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">  &#123;# 包含就显示 #&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> isShow %&#125;</span><br><span class="line">    &#123;% include <span class="string">'includes/post-title-item.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>以上代码在 <code>layout/tag.swig</code> 中，<a href="https://github.com/stiekel/hexo-theme-random/blob/master/layout/tag.swig" target="_blank" rel="noopener">在线代码</a>。</p><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p>首页一般会包括一些链接和最近的几篇文章，使用的模板文章为 <code>layout/index.swig</code>。链接可以固定的，比如，显示首页、存档页。也可以从配置文件中读取链接列表，再予以显示。</p><p>如果要显示最近的几篇文章的列表，可以使用 <code>page.posts</code> 中的文章列表，注意加上翻页链接。</p><h3 id="分类列表页与分类文章列表页"><a href="#分类列表页与分类文章列表页" class="headerlink" title="分类列表页与分类文章列表页"></a>分类列表页与分类文章列表页</h3><p>分类列表页显示博客里的所有分类，分类文章列表页显示某个分类中的文章列表。</p><p>Hexo 并没有专门分类列表页的模板，那该如何处理呢？一般是写在页面模板中，即 <code>layout/page.swig</code> 里，然后判断页面类型变量 <code>page.type</code>，如果是 <code>categories</code>，则显示分类列表页。再在博客里创建一个页面，指定其 <code>type</code> 为 <code>categories</code> 。实现方法如下，先来看看 <code>layout/page.swig</code> 中的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends <span class="string">'includes/layout.swig'</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">  &lt;article id=<span class="string">"page"</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">set</span> page_title = page.title %&#125;</span><br><span class="line">    &#123;# 判断是否是分类列表页，如果是，显示对应内容 #&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> <span class="string">'categories'</span> === page.type %&#125;</span><br><span class="line">      &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"center-title"</span>&gt;&#123;&#123; page_title || __(<span class="string">'category_title'</span>) &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;&#123; list_categories() &#125;&#125;</span></span><br><span class="line"><span class="regexp">    &#123;# 显示普通页面的内容 #&#125;</span></span><br><span class="line"><span class="regexp">    &#123;% else %&#125;</span></span><br><span class="line"><span class="regexp">      &lt;h1 class=""&gt;&#123;&#123; page_title &#125;&#125;&lt;/</span>h1&gt;</span><br><span class="line">      &#123;% autoescape <span class="literal">false</span> %&#125;&#123;&#123;page.content &#125;&#125;&#123;% endautoescape %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &lt;<span class="regexp">/article&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#123;% include 'includes/</span>pagination.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">&#123;% endblock %&#125;</span></span><br></pre></td></tr></table></figure><p>要显示所有的分类，这里是使用了 <code>list_category()</code> 来显示，也可以从 <code>site.categories</code> 中遍历组织显示。接着，使用如下命令创建一个页面：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>然后在站点的 <code>source</code> 文件夹下，会多出来一个名为 <code>categories</code> 的文件夹，只包括一个名为 <code>index.md</code> 的文件，内容如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2016-06-19 10:29:23</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>将其内容修改为：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2016-06-19 10:29:23</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样，Hexo 在生成页面时，判断到 <code>type</code> 为 <code>categories</code>，便会生成分类列表。页面的地址为 <code>/categories/</code>。</p><p>而对于分类文章列表页，则需要在 <code>layout/category.swig</code> 中编辑。具体的文章列表，可以从 <code>page.posts</code> 中取，也可以从 <code>site.posts</code> 中取文章，再根据文章分类筛选显示。</p><h3 id="标签列表页与标签文章列表页"><a href="#标签列表页与标签文章列表页" class="headerlink" title="标签列表页与标签文章列表页"></a>标签列表页与标签文章列表页</h3><p>这个与分类的处理类似，不做重复介绍。</p><h3 id="归档页"><a href="#归档页" class="headerlink" title="归档页"></a>归档页</h3><p>归档页使用的 <code>layout/archive.swig</code> 模板，一般是按年或按月来显示文章。Hexo 里其实有专门按年和月显示的文章列表页，从 <code>page.posts</code> 里读取文章列表，再根据上文中提到的<code>is_month()</code> / <code>is_year()</code> 来组织显示。</p><p>文章列表显示比较简单，单说一点，如何按年分隔来显示文章列表，当然，按月分隔显示的操作也一样。</p><p>操作方法其实比较简单，先遍历 <code>page.posts</code> ，判断当年文章对比前一篇文章的发表年份是否变化，如果变化，则加一个年份的显示，代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;# 先遍历一篇文章列表，找出每年各发了多少文章，以便显示 #&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> howMuch = &#123;&#125; %&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> postItem <span class="keyword">in</span> page.posts.toArray() %&#125;</span><br><span class="line">  &#123;% <span class="keyword">set</span> thisYear = date(postItem.date, 'YYYY') %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> !howMuch[thisYear] %&#125;</span><br><span class="line">    &#123;% <span class="keyword">set</span> howMuch[thisYear] = 0 %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% <span class="keyword">set</span> howMuch[thisYear] = howMuch[thisYear] + 1 %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;# 开始显示， lastYear 为上一篇文章的发表年份 #&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> lastYear %&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> postItem <span class="keyword">in</span> page.posts.toArray() %&#125;</span><br><span class="line">  &#123;# 当前文章的发表年份 #&#125;</span><br><span class="line">  &#123;% <span class="keyword">set</span> thisYear = date(postItem.date, 'YYYY') %&#125;</span><br><span class="line">  &#123;# 如果当前文章年份与上一篇不一样，则显示年份 #&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> thisYear !== lastYear %&#125;</span><br><span class="line">    &#123;% <span class="keyword">set</span> lastYear = thisYear %&#125;</span><br><span class="line">    &lt;h3 class="archive-year-title"&gt;&#123;&#123; thisYear &#125;&#125;</span><br><span class="line">    &#123;# 年份后面，显示一下这年共发表了多少篇文章 #&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> howMuch[thisYear] %&#125;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"posts-count"</span>&gt;</span><br><span class="line">      &#123;&#123; __(<span class="string">'total_title'</span>) &#125;&#125;</span><br><span class="line">      &#123;&#123; howMuch[thisYear] &#125;&#125;</span><br><span class="line">      &#123;% <span class="keyword">if</span> <span class="number">1</span> === howMuch[thisYear] %&#125;</span><br><span class="line">        &#123;&#123; __(<span class="string">'post_title'</span>) &#125;&#125;</span><br><span class="line">      &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">        &#123;&#123; __(<span class="string">'posts_title'</span>) &#125;&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &#123;% else %&#125;</span></span><br><span class="line"><span class="regexp">        &#123;&#123; __('not_post') &#125;&#125;</span></span><br><span class="line"><span class="regexp">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>h3&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% include <span class="string">'post-title-item.swig'</span> %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h3 id="图片与图片库"><a href="#图片与图片库" class="headerlink" title="图片与图片库"></a>图片与图片库</h3><p>文章的图片放在 <code>photos</code> 之中，在 <code>page.photos</code> 和 <code>post.photos</code> 中都有。Hexo 主题一般的做法是使用 <a href="http://fancyapps.com/fancybox/" target="_blank" rel="noopener">FancyBox</a> 来展示图片。</p><p>两个地方可能要显示图片，一个是文章或页面的详情中， 另外一个是在各个文章列表中。</p><h3 id="代码的显示"><a href="#代码的显示" class="headerlink" title="代码的显示"></a>代码的显示</h3><p>代码段一般是使用 <a href="">highlight</a> 的样式，直接加载它的 css 就行。另外可能需要调整一下代码段的 <code>padding</code> 和 <code>margin</code> ，另外就是字体。具体被 highlight 处理后的代码段的 HTML 结构，请通过 Chrome 调试工具查看，这里就不列了。</p><p>除了代码段，在正文中之内还有一些代码文字，会使用 <code>&lt;code&gt;&lt;/code&gt;</code> 标签包裹，这个需要单独针对这个标签设置样式。比如，可以给一个浅灰的背景色，再改个字体，加个斜体等等。</p><p>代码的字体，可以 <a href="http://www.cssfontstack.com/" target="_blank" rel="noopener">www.cssfontstack.com</a> 上找一组合适的，并且兼容 Windows / OS X 的字符，比如下面这个：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">table</span> <span class="selector-class">.line</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Consolas, Monaco, Courier New, Lucida Console;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主题的发布"><a href="#主题的发布" class="headerlink" title="主题的发布"></a>主题的发布</h2><p>如果你想要更多的人看到你的主题，可以考虑发布到 Hexo 官方网站的主题列表中。需要经过几个步骤来实现。</p><h3 id="主题测试"><a href="#主题测试" class="headerlink" title="主题测试"></a>主题测试</h3><p>官方提供了一个站点的示例，里面包含了多种需要考虑的可能情况。克隆 <a href="https://github.com/hexojs/hexo-theme-unit-test" target="_blank" rel="noopener">hexo-theme-unit-test</a> ，然后在这个站点里安装你的主题。并确定主题可以成功的处理如下几种类型的文章：</p><ul><li>图片文章</li><li>无标题的文章</li><li>带摘要的文章</li><li>带视频的文章</li><li>带图库的文章</li><li>支持常用的标签，如代码块、Gist、jsFddle和引用等</li><li>标签是网址的文章</li><li>对东亚文字的支持——必然的</li></ul><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>先 Fork 官方站点，<a href="https://github.com/hexojs/site" target="_blank" rel="noopener">hexojs/site</a> ，然后克隆到本地，再编辑站点内 <code>source/_data/theme.yml</code>，增加一段如下的数据：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- name: Random</span><br><span class="line">  description: A hexo theme with random fullscreen background image.</span><br><span class="line">  link: https://github.com/stiekel/hexo-theme-random</span><br><span class="line">  preview: http://hexo-theme-random.herokuapp.com/</span><br><span class="line">  tags:</span><br><span class="line">    - responsive</span><br><span class="line">    - one_column</span><br><span class="line">    - background_image</span><br><span class="line">    - random</span><br><span class="line">    - iconfont</span><br><span class="line">    - modal</span><br></pre></td></tr></table></figure><p>然后再在 <code>source/theme/screenshots/</code> 文件夹中放一个主题截图，尺寸为 800 * 500 ，文件名与主题名字一致。可以参考<a href="https://raw.githubusercontent.com/hexojs/site/master/source/themes/screenshots/Random.png" target="_blank" rel="noopener">这个图片</a>。</p><p>其实主题制作，主要是各种细节，按你想要的样子去实现吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你看到你用的主题出现在两个以上的博客的时候，那你就要考虑自己写一个了。本文的主角是 Hexo ，如果你没有用过，那可以考虑 &lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://chensd.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Hexo" scheme="http://chensd.com/tags/Hexo/"/>
    
      <category term="Blog" scheme="http://chensd.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>CSS 模拟实现 Material Design 样式的悬浮操作按钮</title>
    <link href="http://chensd.com/2016-06/Material-Design-Float-Action-Button.html"/>
    <id>http://chensd.com/2016-06/Material-Design-Float-Action-Button.html</id>
    <published>2016-06-05T00:08:19.000Z</published>
    <updated>2021-03-10T23:07:38.714Z</updated>
    
    <content type="html"><![CDATA[<p>Material Design 的悬浮操作按钮虽然会挡住一部分页面内容，但的确提供了一种不错的表现操作按钮的思路。手里一个微信的项目正好准备试试用这种风格来表现创建一类的操作。关于 Material Design 的按钮介绍，可以看<a href="https://www.google.com/design/spec/components/buttons.html#buttons-button-types" target="_blank" rel="noopener">这里</a>。</p><p>这里实现一个类似于 Gmail App 中的新建邮件按钮风格类似的样式，为了简便，就直接使用一个样式来完成，元素的 HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float-action-button"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="按钮的定位"><a href="#按钮的定位" class="headerlink" title="按钮的定位"></a>按钮的定位</h3><p>悬浮操作按钮一般是位于屏幕的右下方，并且位置不随网页的滚动而变化。这可以通过设置 <code>position</code> 为 <code>fixed</code> 来实现，位置则通过 <code>bottom</code> 和 <code>right</code> 来指定。另外还修改一下光标的指针样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float-action-button</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮的颜色与形状"><a href="#按钮的颜色与形状" class="headerlink" title="按钮的颜色与形状"></a>按钮的颜色与形状</h3><p>这里的颜色包括四个，分别是：</p><ul><li>按钮的主体背景色</li><li>按钮的边框颜色</li><li>按钮中铅笔图标的铅笔颜色</li><li>按钮的阴影色</li></ul><p>其中前两个颜色类似，而主体色要比边框色稍微浅一点。如果你有颜色选择困难症，可以直接使用 <a href="https://www.google.com/design/spec/style/color.html#" target="_blank" rel="noopener">Material Design 颜色推荐表</a>，或者试试这两个扁平化设计颜色推荐网站：<a href="http://www.flatuicolorpicker.com/" target="_blank" rel="noopener">flatuicolorpicker.com</a>、<a href="https://flatuicolors.com/" target="_blank" rel="noopener">flatuicolors.com</a>。我用的是 flatuicolorpicker 上的颜色。</p><p>圆形通过设置 <code>border-radius</code> 可以实现，其值大于 <code>50%</code> 时可以表现为圆形。这里借助 <code>padding</code> 来设置按钮的大小。</p><p>设置颜色和形状如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float-action-button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#D91E18</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#F2F1EF</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="按钮的图标"><a href="#按钮的图标" class="headerlink" title="按钮的图标"></a>按钮的图标</h3><p>按钮中有一个铅笔的图标，这里为了简单，直接使用一个图片来实现。目前发现的最丰富的图标资源站，当然是 <a href="http://iconfont.cn/" target="_blank" rel="noopener">iconfont</a> ，搜索 <code>pencil</code> 可以找到 258 个图标，挑一个就行。但要注意，因为背景色为深色，为了使铅笔看起来相对明显一点，最好选择图标中着色面积大的。鼠标指向图标可以显示下载按钮，着色要与背景色形成对象，使用白色，或者浅灰，这里直接使用 iconfont 推荐的 <code>#ecf0f1</code> 。</p><p>背景图要设置为居中，不重复。大小为整个按钮大小的一半——将 <code>background-size</code> 设置为 <code>padding</code> 值即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float-action-button</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'./pencil.png'</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮的边框"><a href="#按钮的边框" class="headerlink" title="按钮的边框"></a>按钮的边框</h3><p>按钮有一个很细的边框，颜色相对背景色要稍深一点，通过 <code>border</code> 来设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float-action-button</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#CF000F</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮的阴影"><a href="#按钮的阴影" class="headerlink" title="按钮的阴影"></a>按钮的阴影</h3><p>CSS 的阴影有两种， <code>text-shadow</code> 和 <code>box-shadow</code> ，前者用于指定文字阴影，这里要使用 <code>box-shadow</code>，它典型的值有五个，分别是x轴偏移、y轴偏移、blur 模糊的半径、发散半径、阴影颜色。悬浮操作按钮只有 y 轴偏移。而且颜色很浅。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float-action-button</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">3px</span> <span class="number">9px</span> <span class="number">2px</span> <span class="number">#BFBFBF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悬停样式"><a href="#悬停样式" class="headerlink" title="悬停样式"></a>悬停样式</h3><p>当鼠标经过和点击之后，要模板一个按钮按下的效果，直接通过修改背景色和加大阴影 y 轴偏移即可，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float-action-button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F22613</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">6px</span> <span class="number">9px</span> <span class="number">2px</span> <span class="number">#BFBFBF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>请参见 <a href="/code/floatActionButton.html">Demo</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Material Design 的悬浮操作按钮虽然会挡住一部分页面内容，但的确提供了一种不错的表现操作按钮的思路。手里一个微信的项目正好准备试试用这种风格来表现创建一类的操作。关于 Material Design 的按钮介绍，可以看&lt;a href=&quot;https://www.
      
    
    </summary>
    
      <category term="随手记" scheme="http://chensd.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://chensd.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>利用 EncloseJS 来打包、加密和保护 Node.js 代码</title>
    <link href="http://chensd.com/2016-05/EncloseJS.html"/>
    <id>http://chensd.com/2016-05/EncloseJS.html</id>
    <published>2016-05-22T03:52:33.000Z</published>
    <updated>2021-03-10T23:07:38.713Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js 从来都不是一个面向传统行业的解决方案，无论是安装还是部署，当然也就没有打包工具，更没有考虑如何加密或保护代码，不过在实际部署中，总会碰到：</p><ul><li>想把程序打包为一个单文件</li><li>想让别人不那么方便的获取源代码，对代码做基本的加密或保护</li><li>不想每次都 <code>npm i</code></li><li>想更方便的进行大规模部署</li></ul><p>绝大多数情况下，我们都不是那个首次面对某个问题的人。而这些需求实在是太普通了，开源的，收费的解决方案都有。<a href="http://enclosejs.com/" target="_blank" rel="noopener">EncloseJS</a> 就是一个收费方案。<br><a id="more"></a></p><h2 id="EncloseJS-可以做什么"><a href="#EncloseJS-可以做什么" class="headerlink" title="EncloseJS 可以做什么"></a>EncloseJS 可以做什么</h2><ul><li>将源代码打成一个单文件</li><li>打成的包直接运行，无需 <code>npm i</code> 等安装工作</li><li>打成的包运行时<strong>不依赖 Node.js 和 npm</strong></li></ul><p>虽然还有制作解压缩包和配合 <a href="https://github.com/breach/node-thrust/" target="_blank" rel="noopener">node-thrust</a> 打包 GUI 应用之类，不过这几个基本不是这里要关心的。</p><h2 id="EncloseJS-安装"><a href="#EncloseJS-安装" class="headerlink" title="EncloseJS 安装"></a>EncloseJS 安装</h2><p>试用版安装非常简单，直接使用 <code>npm i -g enclose</code> 即可。不过需要下载的安装包有好几个，我在阿里云的服务器尝试了好几次都没有成功。</p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>我以手头的一个 Socket.io 项目为例做了一个测试，该项目依赖如下：</p><ul><li>redis</li><li>http</li><li>socket.io</li><li>generic-pool</li><li>nutcracker（有依赖，但没有使用）</li></ul><p>EncloseJS 打包，如果只是打包 Node.js 的基本代码文件，那直接使用命令行就够了，当然如果需要包括的文件和目录比较多，可以使用单独的文件来指定，具体可参考<a href="https://github.com/igorklopov/enclose/wiki/02.Packaging#explicit-packaging" target="_blank" rel="noopener">文档</a>。</p><p>这里使用命令行工具就行了，打包命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enclose -l info -x -o ./sio ~/code/sio/bin/socket</span><br></pre></td></tr></table></figure><p>这里使用的几个参数作用如下：</p><ul><li><code>-l info</code>：显示的内容的级别，<code>info</code> 会显示出具体打包的文件列表</li><li><code>x</code>：打包为 x64</li><li><code>-o ./sio</code>：打包后的文件，存储到当前目录，命令为 <code>ess</code></li><li><code>~/code/eschool_server/bin/socket</code>：Node.js 应用的入口文件，也就是 <code>node</code> 命令执行的那个文件</li></ul><p>打包速度还是很快的，结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ll ./ess</span><br><span class="line">-rwxr-xr--  1 sid  staff    18M May 21 11:38 ./ess</span><br><span class="line">$ file ./ess</span><br><span class="line">./ess: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure><p>打包另外一个项目时，发现对 <code>require</code> 语句中使用字符串拼接的路径支持会有问题。</p><p>对比其它的方案，EncloseJS 还是非常有优势的，至少打包这个测试项目时是一次性成功。它的试用版是有限制的，运行的时候，会打印一个试用提示，还有网络连接数和进程运行时间的限制。<a href="http://enclosejs.com/buy" target="_blank" rel="noopener">购买</a>订阅的价格是一年100刀，对于企业来讲也不贵。</p><h2 id="其它的选择"><a href="#其它的选择" class="headerlink" title="其它的选择"></a>其它的选择</h2><p>开源的方案也有几个，比如 <a href="https://github.com/jaredallard/nexe" target="_blank" rel="noopener">nexe</a> / <a href="https://github.com/jxcore/jxcore" target="_blank" rel="noopener">jxcore</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js 从来都不是一个面向传统行业的解决方案，无论是安装还是部署，当然也就没有打包工具，更没有考虑如何加密或保护代码，不过在实际部署中，总会碰到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想把程序打包为一个单文件&lt;/li&gt;
&lt;li&gt;想让别人不那么方便的获取源代码，对代码做基本的加密或保护&lt;/li&gt;
&lt;li&gt;不想每次都 &lt;code&gt;npm i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;想更方便的进行大规模部署&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绝大多数情况下，我们都不是那个首次面对某个问题的人。而这些需求实在是太普通了，开源的，收费的解决方案都有。&lt;a href=&quot;http://enclosejs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EncloseJS&lt;/a&gt; 就是一个收费方案。&lt;br&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>发布了一个 Hexo 的新主题：Random</title>
    <link href="http://chensd.com/2016-05/hexo-theme-random.html"/>
    <id>http://chensd.com/2016-05/hexo-theme-random.html</id>
    <published>2016-05-19T22:17:40.000Z</published>
    <updated>2021-03-10T23:07:38.728Z</updated>
    
    <content type="html"><![CDATA[<p>把博客从 Wordpress 转换到 Hexo 之后，大部分的时间使用的就是 NeXT 这个主题，不过一直不是很喜欢在文章列表中显示摘要，加上最近发现了一个提供随机图片的服务 <a href="http://source.unsplash.com/" target="_blank" rel="noopener">unsplash</a>，所以决定自己来写一款 Hexo 主题。</p><p>五一假期的时候动工的，一直到 19 号早上提交到 Hexo 的官方主题列表，总共花了差不多 20 天，大问题已经差不多解决了，不过 css 写得挺乱的。第一次做博客程序的主题，收获还是挺多的，接触了两个新技术，一个是模板引擎 swig，一个是 css 预编译 stylus ——前同天才看到， swig 已经停止更新一年多了。还发现了 <a href="http://iconfont.cn/" target="_blank" rel="noopener">iconfont</a> 这个相当不错的平台。另外就是用了一下在 Github Tending 上发现的视频插件 <a href="https://plyr.io/" target="_blank" rel="noopener">plyr</a> ，界面还挺不错。部署时，由于 Github 上单个 repo 所属的 Github pages 与 stiekel.github.io 的发生冲突，所以用上了注册了很久的 heroku 账号，感叹国内速度 Github Pages 快多了。</p><p>在制作主题的过程中，借鉴了 <a href="https://github.com/LouisBarranqueiro/tranquilpeak-hexo-theme" target="_blank" rel="noopener">Tranquilpeak</a> 这个主题，以及 <a href="http://iwritejs.com/who-is-using-jquery/" target="_blank" rel="noopener">IwJS</a> 中的翻页按钮——不过目前做得没这个漂亮。主题的基础是使用 <a href="https://github.com/tcrowe/generator-hexo-theme" target="_blank" rel="noopener">generator-hexo-theme</a> 生成的。</p><p>由于使用了 unsplash 的随机图片作为背景图，所以主题定名为 Random ，主要特色如下：</p><ul><li>使用只有基本信息和链接的首页</li><li>使用随机轮播大图作为背景，感谢 <a href="http://source.unsplash.com/" target="_blank" rel="noopener">unsplash</a> 和 <a href="http://vegas.jaysalvat.com/" target="_blank" rel="noopener">vegas</a></li><li>放弃在存档、标签和分类列表中使用摘要显示</li><li>放弃在存档、标签和分类列表中使用翻页功能</li><li>在存档、标签和分类列表中支持图库的显示</li><li>使用 plyr 来作为视频的播放器</li></ul><p>当然，自己的博客第一时间切换到了新主题，最后放上链接：</p><ul><li>heroku 的 <a href="hexo-theme-random.herokuapp.com">demo</a> </li><li>Github 上的 <a href="https://github.com/stiekel/hexo-theme-random" target="_blank" rel="noopener">hexo-theme-random</a>  repo </li><li><a href="https://github.com/stiekel/hexo-theme-random/blob/master/README.CN.md" target="_blank" rel="noopener">hexo-theme-random 中文文档</a></li></ul><p>有问题或建议，欢迎提 issue。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把博客从 Wordpress 转换到 Hexo 之后，大部分的时间使用的就是 NeXT 这个主题，不过一直不是很喜欢在文章列表中显示摘要，加上最近发现了一个提供随机图片的服务 &lt;a href=&quot;http://source.unsplash.com/&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="建站相关" scheme="http://chensd.com/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Hexo" scheme="http://chensd.com/tags/Hexo/"/>
    
      <category term="Blog" scheme="http://chensd.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>应用内 Waterline 实例的共享</title>
    <link href="http://chensd.com/2016-05/Share-Waterline-Models.html"/>
    <id>http://chensd.com/2016-05/Share-Waterline-Models.html</id>
    <published>2016-05-13T01:46:42.000Z</published>
    <updated>2021-03-10T23:07:38.716Z</updated>
    
    <content type="html"><![CDATA[<p>相对于 Mongoose 的初始化来讲，Waterline 的要麻烦得多，首先 Waterline 的初始化是异步的，其次，它是返回一个全新的对象，所以不得不使用单独的代码，来解决应用内共享同一个数据库的 models 。<a href="/2015-10/Use-Waterline-in-Express-project.html">在 Express 项目中使用 Waterline</a>一文中，我们是将所有的集合加载到 Express 的实例中，网友 wuwanyu 问道，还有没有其它的办法，让应用内能够更方便的共享 Waterline 实例。</p><p>在 Node.js 中，模块是单例模式共享的，所以可以利用这一特性来在应用内共享 Waterline 实例。下面的代码依然是基于 <a href="https://github.com/stiekel/waterline-sample" target="_blank" rel="noopener">waterline-sample</a> 。</p><p>首先，为了程序的可读性，我们在 <code>config/waterline.js</code> 的最后一行，增加一个导出的变量，用以存放 waterline 中所有 models 的引用，将其初始化为 <code>null</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.orm = orm;</span><br><span class="line">exports.config = wlconfig;</span><br><span class="line">exports.models = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>接着，在初始化的时候，将其赋值，修改 <code>bin/www</code> 相关代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../config/config'</span>);</span><br><span class="line"><span class="keyword">var</span> waterline = <span class="built_in">require</span>(<span class="string">'../config/waterline'</span>);</span><br><span class="line"></span><br><span class="line">waterline.orm.initialize(waterline.config, <span class="function"><span class="keyword">function</span>(<span class="params">err, models</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  waterline.models = models.collections;</span><br><span class="line">  <span class="comment">// app.set('models', models.collections);</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以后，直接使用 <code>config/waterline.js</code> 中导出的 <code>models</code> 即可进行 Waterline 的相关操作了，比如，在控制器中，可以这样操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> waterline = <span class="built_in">require</span>(<span class="string">'../../config/waterline'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  list: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> page = <span class="built_in">parseInt</span>(req.query.page, <span class="number">10</span>) ? <span class="built_in">parseInt</span>(req.query.page, <span class="number">10</span>) : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> limit = <span class="built_in">parseInt</span>(req.query.limit, <span class="number">10</span>) ? <span class="built_in">parseInt</span>(req.query.limit, <span class="number">10</span>) : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// req.models.post</span></span><br><span class="line">    waterline.models.post</span><br><span class="line">    .find()</span><br><span class="line">    .paginate(&#123;<span class="attr">page</span>: page, <span class="attr">limit</span>: limit&#125;)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>)</span>&#123;</span><br><span class="line">      res.json(docs);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，其它所有需要在应用内进行共享的数据，都可以通过 Node.js 模块的单例特性来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相对于 Mongoose 的初始化来讲，Waterline 的要麻烦得多，首先 Waterline 的初始化是异步的，其次，它是返回一个全新的对象，所以不得不使用单独的代码，来解决应用内共享同一个数据库的 models 。&lt;a href=&quot;/2015-10/Use-Wate
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
      <category term="Waterline" scheme="http://chensd.com/tags/Waterline/"/>
    
  </entry>
  
  <entry>
    <title>使用 NW.js 将 Web 应用打包为桌面应用</title>
    <link href="http://chensd.com/2016-04/Transfer-web-app-to-desktop-app-with-NW-js.html"/>
    <id>http://chensd.com/2016-04/Transfer-web-app-to-desktop-app-with-NW-js.html</id>
    <published>2016-04-03T08:01:51.000Z</published>
    <updated>2021-03-10T23:07:38.716Z</updated>
    
    <content type="html"><![CDATA[<p>平时工作中经常需要开发各种管理后台，为了提升开发效率，一般会使用 Bootstrap 一类的 CSS 框架，使用 AngularJS 一类的单页应用框架，让 Web 开发能够更好的将精力集中在业务逻辑上。但逃不过另外一个麻烦，那便是跨浏览器的兼容问题。所以我一般的粗暴做法是，干脆就不支持 IE 浏览器，通过 userAgent 判断并提示用户切换到 Chrome 。其实，除了这个办法之外，还可以考虑将 Web 应用打包为桌面应用。开源社区提供了 NW.js 来轻松的将 Web 应用打包为桌面应用，这样只需要做到兼容 Chrome 就够了。<br><a id="more"></a></p><h3 id="NW-js-简介"><a href="#NW-js-简介" class="headerlink" title="NW.js 简介"></a>NW.js 简介</h3><p>NW.js 由 node-webkit 改名而来。目的是想利用 JavaScript 来进行桌面应用开发。与操作系统交互的部分，利用 Node.js 来完成，而与用户交互的部分，则是使用的网页开发技术。国内比较有名的案例有钉钉的桌面版，有名的 Chrome 插件 Fawave 也还利用 NW.js 推出了桌面应用。</p><p>与 NW.js 类似的解决方案，还有 Github 为了开发 Atom 而推出的 <a href="http://electron.atom.io/" target="_blank" rel="noopener">Electron.js</a> 。Slack 的桌面版就是基于它开发的。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>需要安装以下几个：</p><ul><li>Node.js <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download</a></li><li>NW.js <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download</a></li></ul><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>配置文件就是 Node.js 中常见的 <code>package.json</code> ，最简单的示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"http://chensd.com/"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"window"</span>: &#123;</span><br><span class="line">    <span class="attr">"width"</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="attr">"height"</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">"frame"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"toolbar"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"icon"</span>: 'assets/icon.png'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个参数解释如下：</p><ul><li><code>main</code>：程序的入口，这里就是一个网址</li><li><code>window.height</code> / <code>window.width</code>：应用启动时的窗口大小</li><li><code>window.frame</code>：是否显示桌面应用的标题栏</li><li><code>window.toolbar</code>：是否显示浏览器中的前进后退和地址栏</li><li><code>window.icon</code>：这个就是图标了</li></ul><p>在程序目录中执行如下的命令，可以查看效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nw .</span><br></pre></td></tr></table></figure><h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h3><p>打包可以使用一个 Node.js 模块 <code>nw-builder</code> ，先在程序目录中进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev nw-builder</span><br></pre></td></tr></table></figure><p>然后再创建一个 js 文件来存放打包配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> NwBuilder = <span class="built_in">require</span>(<span class="string">'nw-builder'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nw = <span class="keyword">new</span> NwBuilder(&#123;</span><br><span class="line">  files: <span class="string">'./package.json'</span>, <span class="comment">// 包含文件</span></span><br><span class="line">  platforms: [<span class="string">'win64'</span>], <span class="comment">// 打包的平台</span></span><br><span class="line">  version: <span class="string">'0.12.3'</span> <span class="comment">// 使用 NW.js 的版本</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">nw.on(<span class="string">'log'</span>, <span class="built_in">console</span>.log); <span class="comment">// 日志打印函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始构建</span></span><br><span class="line">nw.build().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done!'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将文件存为 <code>builder.js</code> ，然后使用 Node.js 来执行它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node builder.js</span><br></pre></td></tr></table></figure><p>第一次执行时，会从 nwjs.io 上下载编译好的 Chromium 文件，会花点时间，编译完成后，会在目录中生成 <code>build</code> 文件夹，其中有个按 <code>package.json</code> 中 <code>name</code> 字段命名的目录，这里是 <code>blog</code> ，包含有使用平台命名的目录，这里是 <code>win64</code> ，这便是编译结果，文件列表如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">λ ls -al build\eschool_desktop\win64\</span><br><span class="line">total 49332</span><br><span class="line">drwxr-xr-x    1 Sid      Administ     4096 Apr  6 06:54 ./</span><br><span class="line">drwxr-xr-x    5 Sid      Administ        0 Apr  6 06:54 ../</span><br><span class="line">-rwxr-xr-x    1 Sid      Administ  4173928 Apr  6 06:54 d3dcompiler_47.dll*</span><br><span class="line">-rwxr-xr-x    1 Sid      Administ 61057838 Apr  6 06:54 blog.exe*</span><br><span class="line">-rwxr-xr-x    1 Sid      Administ   987648 Apr  6 06:54 ffmpegsumo.dll*</span><br><span class="line">-rw-r--r--    1 Sid      Administ 10457856 Apr  6 06:54 icudtl.dat</span><br><span class="line">-rwxr-xr-x    1 Sid      Administ    86016 Apr  6 06:54 libEGL.dll*</span><br><span class="line">-rwxr-xr-x    1 Sid      Administ  1890304 Apr  6 06:54 libGLESv2.dll*</span><br><span class="line">drwxr-xr-x    1 Sid      Administ     8192 Apr  6 06:54 locales/</span><br><span class="line">-rw-r--r--    1 Sid      Administ  7482865 Apr  6 06:54 nw.pak</span><br><span class="line">-rwxr-xr-x    1 Sid      Administ 14879232 Apr  6 06:54 pdf.dll*</span><br></pre></td></tr></table></figure><p>这其中，除了可执行文件和 <code>nw.pak</code> 和 <code>icudt.dll</code> 是必须的外，其它都是可以删除的，具体可以参见 <a href="https://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps" target="_blank" rel="noopener">How to package and distribute your apps</a> 文章中的 <strong>Windows</strong> 部分的解释。</p><h3 id="制作安装包"><a href="#制作安装包" class="headerlink" title="制作安装包"></a>制作安装包</h3><p>最后就是做个安装程序来搞定程序文件存储到 Program Files 目录图标放到开始菜单任务栏桌面之类的脏活累活了。自己写安装程序？那可不是 Web 程序员干的事情，当然还是找专业的人来帮忙。比如 <a href="http://www.jrsoftware.org/isinfo.php" target="_blank" rel="noopener">Inno Setup</a> ，当然还有一大票<a href="http://alternativeto.net/software/inno-setup/" target="_blank" rel="noopener">类似的工具</a>。</p><h3 id="打包为-Mac-OS-X-Linux-应用"><a href="#打包为-Mac-OS-X-Linux-应用" class="headerlink" title="打包为 Mac OS X / Linux 应用"></a>打包为 Mac OS X / Linux 应用</h3><p>只需要在 <code>builder.js</code> 中实例化 nw-builder 时多为 <code>platform</code> 数组添加几个值即可，支持的完成列表为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'win32'</span>, <span class="string">'win64'</span>, <span class="string">'osx32'</span>, <span class="string">'osx64'</span>, <span class="string">'linux32'</span>, <span class="string">'linux64'</span>]</span><br></pre></td></tr></table></figure><h3 id="这样做没毛病吗？"><a href="#这样做没毛病吗？" class="headerlink" title="这样做没毛病吗？"></a>这样做没毛病吗？</h3><p>怎么样，看起来不错吧？几分钟二十几行代码就制作了一个桌面应用，而且看起来还人模狗样的。不过你很快会发现，它没有缓存，localStorage 也不持久，每次打开就像第一次打开一样……下次我们来看看如何解决这些问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时工作中经常需要开发各种管理后台，为了提升开发效率，一般会使用 Bootstrap 一类的 CSS 框架，使用 AngularJS 一类的单页应用框架，让 Web 开发能够更好的将精力集中在业务逻辑上。但逃不过另外一个麻烦，那便是跨浏览器的兼容问题。所以我一般的粗暴做法是，干脆就不支持 IE 浏览器，通过 userAgent 判断并提示用户切换到 Chrome 。其实，除了这个办法之外，还可以考虑将 Web 应用打包为桌面应用。开源社区提供了 NW.js 来轻松的将 Web 应用打包为桌面应用，这样只需要做到兼容 Chrome 就够了。&lt;br&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="NW.js" scheme="http://chensd.com/tags/NW-js/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS 中利用 Interceptors 来统一处理 HTTP 的错误</title>
    <link href="http://chensd.com/2016-03/Angular-Handle-Global-Http-Error-with-Interceptors.html"/>
    <id>http://chensd.com/2016-03/Angular-Handle-Global-Http-Error-with-Interceptors.html</id>
    <published>2016-03-11T22:29:26.000Z</published>
    <updated>2021-03-10T23:07:38.711Z</updated>
    
    <content type="html"><![CDATA[<p>Web 开发中，除了数据操作之外，最频繁的就是发起和处理各种 HTTP 请求了，加上 HTTP 请求又是异步的，如果在每个请求中来单独捕获各种常规错误，处理各类自定义错误，那将会有大量的功能类似的代码，或者使用丑陋的方法在每个请求中调用某几个自定义的函数来处理。这两种方法基本都不是靠谱之选。好在 AngularJS 提供了 <a href="https://docs.angularjs.org/api/ng/service/$http#Interceptors" target="_blank" rel="noopener">Interceptors</a>——拦截战斗机——来对应用内所有的 XHR 请求进行统一处理。</p><a id="more"></a><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>Interceptors 有两个处理时机，分别是：</p><ul><li>其它程序代码执行 HTTP 请求之后，在实际从浏览器发出请求之前，即处理请求</li><li>得到请求的响应之后，在交给其它程序代码处理之前，即处理请求的响应</li></ul><p>所以，不难理解它可以用于如下几个方面：</p><ul><li>全局处理错误</li><li>统一进行身份验证一类的处理</li><li>对所有发出去的请求进行预处理</li><li>对所有收到的响应进行预处理</li><li>做一些增强用户体验的操作，例如显示一个进度条</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>先来看看最基本的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'app'</span>, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Service ，稍等将会把它作为 Interceptors 的处理函数</span></span><br><span class="line">app.factory(<span class="string">'HttpInterceptor'</span>, [<span class="string">'$q'</span>, HttpInterceptor]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HttpInterceptor</span>(<span class="params">$q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    request: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    requestError: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> $q.reject(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    response: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    responseError: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="number">-1</span> === err.status) &#123;</span><br><span class="line">        <span class="comment">// 远程服务器无响应</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">500</span> === err.status) &#123;</span><br><span class="line">        <span class="comment">// 处理各类自定义错误</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">501</span> === err.status) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> $q.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加对应的 Interceptors</span></span><br><span class="line">app.config([<span class="string">'$httpProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$httpProvider</span>)</span>&#123;</span><br><span class="line">  $httpProvider.interceptors.push(HttpInterceptor);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><h3 id="进一步了解"><a href="#进一步了解" class="headerlink" title="进一步了解"></a>进一步了解</h3><p>实际的 Interceptor 处理函数中， <code>return</code> 了一个包含四个成员的对象，这四个成员都<strong>不是必须</strong>的，可以按实际情况指定一二，分别如下：</p><ul><li><strong><code>request</code></strong>：接收一个参数，它是 <code>$http</code> 中的标准 <a href="https://docs.angularjs.org/api/ng/service/$http#usage" target="_blank" rel="noopener">config</a> 对象，同时也需要返回一个标准 <code>config</code> ，此时可以添加各类身份验证信息，同时也可在此启动进度条</li><li><strong><code>requestError</code></strong>：当有多个 Interceptor 的时候，<code>requestError</code> 会在前一个 Interceptor 抛出错误或者执行 <code>$q.reject()</code> 时执行，接收的参数就对应的错误</li><li><strong><code>response</code></strong>：接受一个请求对象参数，可以不处理就直接返回，此时也可以将进度条显示为成功完成，当然，如果后端 API 返回自定义错误时，HTTP 的状态码仍然是 200 得话，便在这里处理自定义错误，也可以对返回数据做一些处理，注意要将进度条置为完成</li><li><strong><code>responseError</code></strong>：这个是重头戏，即可以处理标准的 Http 错误，如服务器没有响应时，或者 PHP 之类的 CGI 经常出现的 502 一类，还可以处理 HTTP 状态码不是 200 的各类自定义错误</li></ul><p>上面四个中，前两个是请求的前置处理，后两个是针对请求的响应的处理。</p><h3 id="几个相关的库"><a href="#几个相关的库" class="headerlink" title="几个相关的库"></a>几个相关的库</h3><p>显示进度：</p><ul><li><a href="http://ricostacruz.com/nprogress/" target="_blank" rel="noopener">NProgress</a> </li><li><a href="http://victorbjelkholm.github.io/ngProgress/" target="_blank" rel="noopener">NgProgress</a> NProgress for AngularJS</li><li><a href="http://react-component.github.io/progress/" target="_blank" rel="noopener">rc-progress</a></li><li><a href="https://github.com/bahmutov/progress-full-width" target="_blank" rel="noopener">progress-full-width</a></li><li><a href="http://jkroso.github.io/progress-svg/" target="_blank" rel="noopener">progress-svg</a></li></ul><p>提示框：</p><ul><li><a href="http://codeseven.github.io/toastr/demo.html" target="_blank" rel="noopener">toastr</a></li><li><a href="http://tamerayd.in/ngToast/#" target="_blank" rel="noopener">ngToast</a> toast for AngularJS</li><li><a href="http://jackhanford.com/angular-toast/" target="_blank" rel="noopener">angular-toast</a></li><li><a href="https://derby-demos.herokuapp.com/derby-ui-toast" target="_blank" rel="noopener">k-toast</a></li><li><a href="https://jaredreich.com/projects/notie.js/" target="_blank" rel="noopener">notie</a></li><li><a href="https://www.npmjs.com/package/ng-notie" target="_blank" rel="noopener">ng-notie</a></li><li><a href="https://egoistian.com/corner-notie/" target="_blank" rel="noopener">corner-notie</a></li></ul><h3 id="代码和-DEMO"><a href="#代码和-DEMO" class="headerlink" title="代码和 DEMO"></a>代码和 DEMO</h3><p>具体请参见代码 <a href="https://github.com/stiekel/angular-interceptors-demo" target="_blank" rel="noopener">Github</a> 、<a href="http://stiekel.github.io/angular-interceptors-demo/" target="_blank" rel="noopener">DEMO</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 开发中，除了数据操作之外，最频繁的就是发起和处理各种 HTTP 请求了，加上 HTTP 请求又是异步的，如果在每个请求中来单独捕获各种常规错误，处理各类自定义错误，那将会有大量的功能类似的代码，或者使用丑陋的方法在每个请求中调用某几个自定义的函数来处理。这两种方法基本都不是靠谱之选。好在 AngularJS 提供了 &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$http#Interceptors&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interceptors&lt;/a&gt;——拦截战斗机——来对应用内所有的 XHR 请求进行统一处理。&lt;/p&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS 指令 angular-image-404</title>
    <link href="http://chensd.com/2016-01/AngularJS-Directive-angular-image-404.html"/>
    <id>http://chensd.com/2016-01/AngularJS-Directive-angular-image-404.html</id>
    <published>2016-01-01T00:12:41.000Z</published>
    <updated>2021-03-10T23:07:38.712Z</updated>
    
    <content type="html"><![CDATA[<p>在进行 AngularJS 应用的开发时，经常需要显示图片，而 <code>img</code> 有时候并不能成功的获取到 <code>src</code> 或 <code>ng-src</code> 指定的图片，这时候可能需要通过其它办法来指定一个备用图片，可以想到的办法有：</p><ul><li>在 <code>ng-src</code> 的属性中，指定完普通的图片地址后，使用 <code>||</code> 追加备用图片的地址，如<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng-src='&#123;&#123;"myImg.png" || "fallback.png"&#125;&#125;'</span><br></pre></td></tr></table></figure></li><li>使用 <code>ng-show</code> 和 <code>ng-hide</code> 控制两个 <code>img</code>，其中一个正常显示图片，另外一个显示力求用图片</li></ul><p>开始我也这么做，所以找了一下，发现了一个 AngularJS 指令，<a href="https://github.com/sebasrodriguez/angular-fallback-image" target="_blank" rel="noopener">angular-fallback-image</a> 不过这个指令并不完善，必须指定指令图片才行，我想要的是，就算没有指定图片，也可以显示一个占位性质的图片，于是我做了修改，发了 <a href="https://github.com/sebasrodriguez/angular-fallback-image/pull/1" target="_blank" rel="noopener">Pull Request</a> ，不过这位乌拉圭的<a href="https://github.com/sebasrodriguez" target="_blank" rel="noopener">小哥</a> 似乎有段时间没处理 Github 上的东西了。<br><a id="more"></a></p><p>所以，我开发了 <a href="https://github.com/stiekel/angular-image-404" target="_blank" rel="noopener">angular-image-404</a>，可以自定义占位图，也可以使用默认的占位图。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行 AngularJS 应用的开发时，经常需要显示图片，而 &lt;code&gt;img&lt;/code&gt; 有时候并不能成功的获取到 &lt;code&gt;src&lt;/code&gt; 或 &lt;code&gt;ng-src&lt;/code&gt; 指定的图片，这时候可能需要通过其它办法来指定一个备用图片，可以想到的办法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;ng-src&lt;/code&gt; 的属性中，指定完普通的图片地址后，使用 &lt;code&gt;||&lt;/code&gt; 追加备用图片的地址，如&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ng-src=&#39;&amp;#123;&amp;#123;&quot;myImg.png&quot; || &quot;fallback.png&quot;&amp;#125;&amp;#125;&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ng-show&lt;/code&gt; 和 &lt;code&gt;ng-hide&lt;/code&gt; 控制两个 &lt;code&gt;img&lt;/code&gt;，其中一个正常显示图片，另外一个显示力求用图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开始我也这么做，所以找了一下，发现了一个 AngularJS 指令，&lt;a href=&quot;https://github.com/sebasrodriguez/angular-fallback-image&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;angular-fallback-image&lt;/a&gt; 不过这个指令并不完善，必须指定指令图片才行，我想要的是，就算没有指定图片，也可以显示一个占位性质的图片，于是我做了修改，发了 &lt;a href=&quot;https://github.com/sebasrodriguez/angular-fallback-image/pull/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pull Request&lt;/a&gt; ，不过这位乌拉圭的&lt;a href=&quot;https://github.com/sebasrodriguez&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小哥&lt;/a&gt; 似乎有段时间没处理 Github 上的东西了。&lt;br&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 Gulp 构建 AngularJS / Jade 项目</title>
    <link href="http://chensd.com/2015-11/Use-Gulp-in-AngularJS-and-Jade-project.html"/>
    <id>http://chensd.com/2015-11/Use-Gulp-in-AngularJS-and-Jade-project.html</id>
    <published>2015-11-07T23:22:45.000Z</published>
    <updated>2021-03-10T23:07:38.716Z</updated>
    
    <content type="html"><![CDATA[<p>我所经历的大部分项目，并不是纯粹的前端项目，相关的前端文件，都是使用 Express 来处理，除了 Jade 文件之外的，全部放在 Express 静态文件目录 <code>public</code> 中，Bower 也配置为将依赖包直接安装到 <code>public/lib</code> 目录，然后直接使用原路径在 HTML 中引用对应的 JavaScript / CSS 文件，经常是一个页面加载几十个静态资源。</p><p>上周在做一个 App 项目的商户端，对应的 API 已经完成，只是用 AngularJS 来实现一个前端 Web 页面，其中的 HTML 使用了 Jade 来完成。由于是一个完全的前端项目，终于决定尝试用 Gulp 来进行构建。整体的需求如下：</p><ul><li>使用 Bower 管理前端依赖</li><li>需要将 Jade 文件编码成 HTML，并按照 Angular New Router 中的 Components 来组织目录结构</li><li>将 CSS / JavaScript 文件组装为单个文件</li><li>图片和字体等静态资源存放到对应目录</li><li>使用 Gulp 创建一个调试用的服务器，并能够修改文件后自动重载浏览器页面</li></ul><a id="more"></a><h3 id="项目的目录与文件结构"><a href="#项目的目录与文件结构" class="headerlink" title="项目的目录与文件结构"></a>项目的目录与文件结构</h3><p>整体文件夹结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── app</span><br><span class="line">│   ├── controllers // AngularJS 控制器</span><br><span class="line">│   │   └── home.js</span><br><span class="line">│   ├── modules // AngularJS 模块</span><br><span class="line">│   │   └── app.js</span><br><span class="line">│   ├── services // AngularJS 服务</span><br><span class="line">│   │   └── city.client.service.js</span><br><span class="line">│   └── views // Jade 文件</span><br><span class="line">│       ├── index.jade</span><br><span class="line">│       └── _partial</span><br><span class="line">│           └── home.jade</span><br><span class="line">├── bower.json</span><br><span class="line">├── config.js</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── static</span><br><span class="line">    ├── css</span><br><span class="line">    │   └── style.css</span><br><span class="line">    └── images</span><br><span class="line">        ├── avatar.png</span><br><span class="line">        └── logo.gif</span><br></pre></td></tr></table></figure><p>另外还有个 <code>public</code> 目录，作为发布目录，提供给 Web 服务器对外发布。所有需要在浏览器使用的文件，最后使用都要生成或者复制到 <code>public</code> 中。</p><h3 id="使用-Bower-管理前端依赖"><a href="#使用-Bower-管理前端依赖" class="headerlink" title="使用 Bower 管理前端依赖"></a>使用 Bower 管理前端依赖</h3><p>悲剧，在我定这篇文章的大纲的时候， Bower 还在更新，结果没两天就宣布不再开发了。</p><p>Bower 之所以在以前统治着前端包管理领域，原因在于它的扁平化包管理， NPM 中每个模块都有独立的属于各自的目录，来存储对应的依赖包，虽然会占用比较多的磁盘，但却可以防止模块版本不同而造成的依赖问题。 Bower 本身并不直接决定应用的包依赖，它将模块的依赖同模块本身一样安装。</p><p>自从 NPM 成立专门的公司来运营以后，已经致力于将自己从 <code>Node Package Manager</code> 提升为 <code>JavaScript Package Manager</code>。所以也开始像 Bower 来组织模块的依赖—— Bower 存在的理由又少了一个。</p><p>这两天，网上正在嘲笑 <code>bower --save</code> 并不会把当前已经安装的依赖存储到 <code>bower.json</code> ，不过我怀疑他们没有看到过 NPM 3.3.x 是怎么处理依赖的， <code>npm --save</code> 后的 <code>package.json</code> 估计会相当的不堪入目吧。</p><h3 id="Jade-模板文件转换为-HTML-文件"><a href="#Jade-模板文件转换为-HTML-文件" class="headerlink" title="Jade 模板文件转换为 HTML 文件"></a>Jade 模板文件转换为 HTML 文件</h3><p>以前 Jade 文件是使用 Express 的 <code>view engine</code> 来转译，在专门的路由文件中，一一按照 Angular New Router 的 Components 标准来进行解析。使用 Gulp 转换也是类似，借助 <code>gulp-jade</code> 模块，设置 <code>gulp.src</code> 为 jade 文件路径，<code>gulp.dest</code> 为转换后的 HTML 文件路径，为了方便，将需要转换的 jade 文件和对应的路径组成一个数组，再在 <code>gulp.task</code> 中对数据进行遍历，并执行转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> jade = <span class="built_in">require</span>(<span class="string">'gulp-jade'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jadeFiles = [</span><br><span class="line">  &#123;<span class="attr">src</span>: <span class="string">'./app/views/index.jade'</span>, <span class="attr">dest</span>: <span class="string">'./public/'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">src</span>: <span class="string">'./app/views/_partial/home.jade'</span>, <span class="attr">dest</span>: <span class="string">'./public/components/home/'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'jade'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  jadeFiles.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">jf</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!jf.src || !jf.dest) <span class="keyword">return</span>;</span><br><span class="line">    gulp.src(jf.src)</span><br><span class="line">      .pipe(jade(&#123;<span class="attr">petty</span>: <span class="literal">true</span>&#125;))</span><br><span class="line">      .pipe(gulp.dest(jf.dest));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="将-JavaScript-CSS-文件组装为单个文件"><a href="#将-JavaScript-CSS-文件组装为单个文件" class="headerlink" title="将 JavaScript / CSS 文件组装为单个文件"></a>将 JavaScript / CSS 文件组装为单个文件</h3><p>对于遵循 AngularJS 模块化设计的前端应用， JavaScript 文件那必然是相当多，再加上使用一些扩展，就算是中小型项目，超过 70 个以上那也是相当常见，看 Chrome 开发工具中的 Network 页那可以部是相当精彩，</p><p>如果只是将多个 JavaScript 和 CSS 文件合为一个，使用 <code>gulp-concat</code> 模块即可，压缩 JavaScript 文件，可以再加一个 <code>gulp-uglify</code> 模块，压缩 CSS 文件，可以使用 <code>gulp-minify-css</code> 模块。<code>gulp.src</code> 支持使用数组的方式来指定要处理的文件列表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> minifyCss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> jsFiles = [</span><br><span class="line">    <span class="string">'./bower_components/jquery/dist/jquery.js'</span>, </span><br><span class="line">    <span class="string">'./bower_components/bootstrap/dist/js/bootstrap.min.js'</span>, </span><br><span class="line">    <span class="string">',/bower_components/PACE/pace.min.js'</span>, </span><br><span class="line">    <span class="string">'./bower_components/angular/angular.js'</span>, </span><br><span class="line">    <span class="string">'./bower_components/angular-new-router/dist/router.es5.js'</span>, </span><br><span class="line">    <span class="string">'./bower_components/at-table/dist/angular-table.js'</span>, </span><br><span class="line">    <span class="string">'./app/modules/businessApp.js'</span>, </span><br><span class="line">    <span class="string">'./app/controllers/home.js'</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> cssFiles = [</span><br><span class="line">    <span class="string">'./bower_components/bootstrap/dist/css/bootstrap.min.css'</span>, </span><br><span class="line">    <span class="string">'./bower_components/font-awesome/css/font-awesome.min.css'</span>, </span><br><span class="line">    <span class="string">'./bower_components/PACE/themes/blue/pace-theme-loading-bar.css'</span>, </span><br><span class="line">    <span class="string">'./static/css/start.css'</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 在这两个 `min` 任务之外，还有两个不带 `min` 的任务，区别在于不对文件压缩</span></span><br><span class="line">gulp.task(<span class="string">'scripts_min'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(jsFiles)</span><br><span class="line">    .pipe(concat(<span class="string">'all.js'</span>)) <span class="comment">// 合并 JavaScript ，并设置合并后的文件名</span></span><br><span class="line">    .pipe(uglify()) <span class="comment">// 执行 JavaScript 压缩</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/js'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">'stylesheets_min'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(cssFiles)</span><br><span class="line">    .pipe(concat(<span class="string">'all.css'</span>)) <span class="comment">// 合并 CSS ，并设置合并后的文件名</span></span><br><span class="line">    .pipe(minifyCss()) <span class="comment">// 执行 CSS 压缩</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/stylesheet'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="管理图片字体等静态资源"><a href="#管理图片字体等静态资源" class="headerlink" title="管理图片字体等静态资源"></a>管理图片字体等静态资源</h3><p>对于图片、字体等文件，只是需要使用 Gulp 自带的 <code>gulp.src</code> 和 <code>gulp.dest</code> 来复制到 Web 目录即可。除了这些静态文件，有些文件可能也需要单独处理，比如 JavaScript 中的一些配置项文件，另外，如果使用加载状态提示模块，这个也是需要优秀加载的。顺便安利一下 <a href="http://github.hubspot.com/pace/docs/welcome/" target="_blank" rel="noopener">PACE</a> ，它是个使用相当方便的加载提示模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'pace'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// copy pace.js to js folder</span></span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./bower_components/PACE/pace.min.js'</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其它需要直接复制的文件，也都是类似方法处理。 比如，有大量需要移动的文件，可以使用下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Web 或者编译目录</span></span><br><span class="line"><span class="keyword">var</span> BUILD_FLODER = <span class="string">'dist'</span>;</span><br><span class="line"><span class="comment">// 需要移动的文件列表</span></span><br><span class="line"><span class="keyword">var</span> FilesToMove = [</span><br><span class="line">  <span class="comment">// src 为源路径，dest 为目的位置</span></span><br><span class="line">  &#123; <span class="attr">src</span>: <span class="string">'node_modules/bootstrap/dist/fonts/*'</span>, <span class="attr">dest</span>: <span class="string">'fonts'</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">src</span>: <span class="string">'node_modules/font-awesome/fonts/*'</span>, <span class="attr">dest</span>: <span class="string">'fonts'</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">src</span>: <span class="string">'assets/favicon.ico'</span>, <span class="attr">dest</span>: <span class="string">'/'</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">src</span>: <span class="string">'assets/iconfont/*'</span>, <span class="attr">dest</span>: <span class="string">'css/'</span>&#125;</span><br><span class="line">];</span><br><span class="line">gulp.task(<span class="string">'files'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  FilesToMove.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ftm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ftm.src || !ftm.dest) <span class="keyword">return</span>;</span><br><span class="line">    gulp</span><br><span class="line">    .src(ftm.src)</span><br><span class="line">    .pipe(gulp.dest( path.join(BUILD_FLODER, ftm.dest) ))</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用-Gulp-来创建文件修改后浏览器自动刷新的-Web-服务器"><a href="#使用-Gulp-来创建文件修改后浏览器自动刷新的-Web-服务器" class="headerlink" title="使用 Gulp 来创建文件修改后浏览器自动刷新的 Web 服务器"></a>使用 Gulp 来创建文件修改后浏览器自动刷新的 Web 服务器</h3><p>如果想要文件修改后，浏览器自动刷新，需要做两方面的工作：</p><ul><li>监控 JavaScript / Jade / CSS 文件，修改后重新转换或者压缩</li><li>监控 JavaScript / Jade 文件，修改后刷新浏览器</li><li>监控 CSS 文件的修改，热更新到浏览器</li></ul><p>对于第一个，使用 <code>gulp-watch</code> 模块来监视文件，并执行对应的 Task ，对于第二和第三个，可以使用 <code>gulp-erver-livereload</code> 模块，它可以创建一个 Web 服务器，并且在浏览器和服务器之间创建 Socket.IO 长链接，一旦有文件修改，便通过长链接通知浏览器刷新页面，或者将 css 热更新到浏览器中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'gulp-server-livereload'</span>);</span><br><span class="line"><span class="keyword">var</span> BUILD_FLODER = <span class="string">'dist'</span>;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 不同的文件个性，需要执行不同的任务来处理</span></span><br><span class="line">  gulp.watch([<span class="string">'app/views/*'</span>, <span class="string">'app/views/_partial/*'</span>], [<span class="string">'jade'</span>]);</span><br><span class="line">  gulp.watch([<span class="string">'bower_components/*'</span>], [<span class="string">'scripts'</span>, <span class="string">'stylesheets'</span>]);</span><br><span class="line">  gulp.watch([<span class="string">'static/css/*'</span>], [<span class="string">'stylesheets'</span>]);</span><br><span class="line">  gulp.watch([<span class="string">'app/controllers/*'</span>, <span class="string">'app/modules/*'</span>, <span class="string">'app/services/*'</span>], [<span class="string">'scripts'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'webserver'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 指定 web 目的</span></span><br><span class="line">  gulp.src( path.join(BUILD_FLODER) )</span><br><span class="line">    .pipe(server(&#123;</span><br><span class="line">      <span class="comment">// 是否监视文件修改并刷新</span></span><br><span class="line">      livereload: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 当没有默认页面的时候，是否列出目录内所有的文件</span></span><br><span class="line">      directoryListing: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">      open: <span class="literal">true</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我所经历的大部分项目，并不是纯粹的前端项目，相关的前端文件，都是使用 Express 来处理，除了 Jade 文件之外的，全部放在 Express 静态文件目录 &lt;code&gt;public&lt;/code&gt; 中，Bower 也配置为将依赖包直接安装到 &lt;code&gt;public/lib&lt;/code&gt; 目录，然后直接使用原路径在 HTML 中引用对应的 JavaScript / CSS 文件，经常是一个页面加载几十个静态资源。&lt;/p&gt;
&lt;p&gt;上周在做一个 App 项目的商户端，对应的 API 已经完成，只是用 AngularJS 来实现一个前端 Web 页面，其中的 HTML 使用了 Jade 来完成。由于是一个完全的前端项目，终于决定尝试用 Gulp 来进行构建。整体的需求如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Bower 管理前端依赖&lt;/li&gt;
&lt;li&gt;需要将 Jade 文件编码成 HTML，并按照 Angular New Router 中的 Components 来组织目录结构&lt;/li&gt;
&lt;li&gt;将 CSS / JavaScript 文件组装为单个文件&lt;/li&gt;
&lt;li&gt;图片和字体等静态资源存放到对应目录&lt;/li&gt;
&lt;li&gt;使用 Gulp 创建一个调试用的服务器，并能够修改文件后自动重载浏览器页面&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Gulp" scheme="http://chensd.com/tags/Gulp/"/>
    
  </entry>
  
  <entry>
    <title>在 Express 项目中使用 Waterline</title>
    <link href="http://chensd.com/2015-10/Use-Waterline-in-Express-project.html"/>
    <id>http://chensd.com/2015-10/Use-Waterline-in-Express-project.html</id>
    <published>2015-10-25T17:40:22.000Z</published>
    <updated>2021-03-10T23:07:38.717Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="http://chensd.com/2015-10/Node-ORM-Waterline.html">Node.js ORM 数据操作中间件 Waterline </a>中，我们介绍了 Waterline 的功能与特点，这篇文章中我们将用一个实例 waterline-sample （<a href="https://github.com/stiekel/waterline-sample" target="_blank" rel="noopener">Github</a>、<a href="https://coding.net/u/Stiekel/p/waterline-sample/git" target="_blank" rel="noopener">Coding.NET</a>），来看看在 Express 项目中如何使用 Waterline。</p><p>要在项目中使用 Waterline ，无非是解决如何配置，在什么时机初始化，怎样组织所有的数据集合，以及在控制器中怎么调用 Waterline 中的数据集合这几个问题。<br><a id="more"></a></p><h3 id="项目的功能与结构"><a href="#项目的功能与结构" class="headerlink" title="项目的功能与结构"></a>项目的功能与结构</h3><p>这个示例项目中，将会实现两个关于 Post 的 API ，添加和获取列表的接口，功能比较简单，但代码的组织，依然遵循模块化和 MVC 的设计原则，主要的文件和目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|-- app</span><br><span class="line">|   |-- controllers</span><br><span class="line">|   |   `-- post.server.controller.js</span><br><span class="line">|   |-- models</span><br><span class="line">|   |   `-- post.server.model.js</span><br><span class="line">|   `-- routes</span><br><span class="line">|       `-- post.server.routes.js</span><br><span class="line">|-- config</span><br><span class="line">|   |-- config.js</span><br><span class="line">|   |-- env</span><br><span class="line">|   |   `-- development.js</span><br><span class="line">|   |-- express.js</span><br><span class="line">|   `-- waterline.js</span><br><span class="line">|-- app.js</span><br><span class="line">|-- bin</span><br><span class="line">|   `-- www</span><br><span class="line">`-- package.json</span><br></pre></td></tr></table></figure><p>其中， <code>config</code> 目录存储基本配置、 Express 配置和 Waterline 的配置文件，其中的 <code>env</code> 目录存储根据环境而不同的基本配置。 <code>app</code> 目录下的三个文件夹，分别按 MVC 的结构组织 Waterline 的 Collections ，Expresss 的控制器以及路由文件。根目录下的 <code>app.js</code> 将使用 <code>config/express.js</code> 中的配置来生成 Express 的实例，而入口文件 <code>bin/www</code> 则完成 Waterline 的初始化和启动 Express 实例的端口监听。</p><h3 id="数据集合的组织"><a href="#数据集合的组织" class="headerlink" title="数据集合的组织"></a>数据集合的组织</h3><p>所有的数据集合，全部组织在 <code>app/models</code> 目录中，直接使用 <code>module.exports</code> 来将 <code>Waterline.Collections</code> 实例导出，以便在 Waterline 的配置文件中调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/models/post.server.model.js</span></span><br><span class="line"><span class="keyword">var</span> Waterline = <span class="built_in">require</span>(<span class="string">'waterline'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Waterline.Collection.extend(&#123;</span><br><span class="line">  identity: <span class="string">'post'</span>,</span><br><span class="line">  connection: <span class="string">'mongo'</span>,</span><br><span class="line">  schema: <span class="literal">true</span>,</span><br><span class="line">  attributes: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="string">'string'</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    content: <span class="string">'string'</span>,</span><br><span class="line">    createTime: <span class="string">'date'</span>,</span><br><span class="line">    lastModifyTime: <span class="string">'date'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate: <span class="function"><span class="keyword">function</span>(<span class="params">v, cb</span>)</span>&#123;</span><br><span class="line">    v.createTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> cb();</span><br><span class="line">  &#125;,</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'\tTitle:'</span>, v.title, <span class="string">'create at:'</span>, v.createTime);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'\tContent:'</span>, v.content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里也演示了如何定义生命周期回调和自定义的方法。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置里主要是生成 Waterline 的实例，并加载上面的数据集合配置文件。下面是 Waterline 的配置文件，导出了配置所需要的代码，但并没有执行初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/waterline.js</span></span><br><span class="line"><span class="keyword">var</span> Waterline = <span class="built_in">require</span>(<span class="string">'waterline'</span>);</span><br><span class="line"><span class="keyword">var</span> mongoAdapter = <span class="built_in">require</span>(<span class="string">'sails-mongo'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// models</span></span><br><span class="line"><span class="keyword">var</span> Post = <span class="built_in">require</span>(<span class="string">'../app/models/post.server.model'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orm = <span class="keyword">new</span> Waterline();</span><br><span class="line"><span class="keyword">var</span> wlconfig = &#123;</span><br><span class="line">  adapters: &#123;</span><br><span class="line">    <span class="string">'default'</span>: mongoAdapter,</span><br><span class="line">    mongo: mongoAdapter</span><br><span class="line">  &#125;,</span><br><span class="line">  connections: &#123;</span><br><span class="line">    <span class="string">'mongo'</span>: &#123;</span><br><span class="line">      adapter: <span class="string">'mongo'</span>,</span><br><span class="line">      url: config.mongo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">orm.loadCollection(Post);</span><br><span class="line"></span><br><span class="line">exports.orm = orm;</span><br><span class="line">exports.config = wlconfig;</span><br></pre></td></tr></table></figure><p>这里使用的是 <code>exports</code> 来导出，因为我们有两个值需要导出，一个是 Waterline 的实例，另外一个是 Waterline 的初始化配置。这在 Waterline 初始化的时候会用到。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是在 <code>bin/www</code> 里完成的，原因是保证 Express 启动监听，必须在 Waterline 的成功初始化之后进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bin/www</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../config/config'</span>);</span><br><span class="line"><span class="keyword">var</span> waterline = <span class="built_in">require</span>(<span class="string">'../config/waterline'</span>);</span><br><span class="line"></span><br><span class="line">waterline.orm.initialize(waterline.config, <span class="function"><span class="keyword">function</span>(<span class="params">err, models</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'waterline initialize failed, err:'</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'waterline initialize success.'</span>);</span><br><span class="line">  </span><br><span class="line">  app.set(<span class="string">'models'</span>, models.collections);</span><br><span class="line"></span><br><span class="line">  app.listen(config.port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Express listening on port:'</span>, config.port);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>初始化是直接使用 Waterline 实例的 <code>intialize()</code> 方法，需要传入对应的配置，这两个都是在 <code>waterline.js</code> 配置文件中导出的。为了方便我们在控制器代码中调用 Waterline 的数据集合，这里先将它加入到 Express 实例的配置列表中。</p><h3 id="在-Express-控制器中使用-Waterline-数据集合"><a href="#在-Express-控制器中使用-Waterline-数据集合" class="headerlink" title="在 Express 控制器中使用 Waterline 数据集合"></a>在 Express 控制器中使用 Waterline 数据集合</h3><p>由于 Waterline 的初始化过程是异步的，所以我们没有办法直接使用 <code>module.exports</code> 或 <code>exports</code> 方法来导出它的实例，也就无法直接以 JavaScript 模块化的方式调用它实例中的数据集合。这里将借助 Express 的实例，来在控制器代码中使用它。</p><p>但实际上，在控制器代码中，也是没有办法直接访问 Express 的实例的，所以这里我们在 Express 的配置里，增加一个中间件，将附加在 Express 实例上的数据集合，再加入到 Express 请求对象中，这样便可以在控制器代码中通过请求对象来访问 Waterline 实例的数据集合了。当然，加到响应对象也可以。下面的代码展示了如何在控制器中使用 Waterline 的数据集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/express.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> waterline = <span class="built_in">require</span>(<span class="string">'./waterline'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'express initialing...'</span>);</span><br><span class="line">  <span class="keyword">var</span> app = express();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    req.models = app.get(<span class="string">'models'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'../app/routes/post.server.routes'</span>)(app);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在控制器里，便可以通过请求对象的 <code>models</code> 成员来调用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controllers/post.server.controller.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  list: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> page = <span class="built_in">parseInt</span>(req.query.page, <span class="number">10</span>) ? <span class="built_in">parseInt</span>(req.query.page, <span class="number">10</span>) : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> limit = <span class="built_in">parseInt</span>(req.query.limit, <span class="number">10</span>) ? <span class="built_in">parseInt</span>(req.query.limit, <span class="number">10</span>) : <span class="number">1</span>;</span><br><span class="line">    req.models.post.find().paginate(&#123;<span class="attr">page</span>: page, <span class="attr">limit</span>: limit&#125;).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>)</span>&#123;</span><br><span class="line">      res.json(docs);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然也可以通过全局变量来调用数据集合，不过在有其它办法的情况下，还是尽量不要使用全局变量吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;http://chensd.com/2015-10/Node-ORM-Waterline.html&quot;&gt;Node.js ORM 数据操作中间件 Waterline &lt;/a&gt;中，我们介绍了 Waterline 的功能与特点，这篇文章中我们将用一个实例 waterline-sample （&lt;a href=&quot;https://github.com/stiekel/waterline-sample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;、&lt;a href=&quot;https://coding.net/u/Stiekel/p/waterline-sample/git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding.NET&lt;/a&gt;），来看看在 Express 项目中如何使用 Waterline。&lt;/p&gt;
&lt;p&gt;要在项目中使用 Waterline ，无非是解决如何配置，在什么时机初始化，怎样组织所有的数据集合，以及在控制器中怎么调用 Waterline 中的数据集合这几个问题。&lt;br&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
      <category term="Waterline" scheme="http://chensd.com/tags/Waterline/"/>
    
  </entry>
  
  <entry>
    <title>Node.js ORM 数据操作中间件 Waterline</title>
    <link href="http://chensd.com/2015-10/Node-ORM-Waterline.html"/>
    <id>http://chensd.com/2015-10/Node-ORM-Waterline.html</id>
    <published>2015-10-25T08:31:51.000Z</published>
    <updated>2021-03-10T23:07:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在看 <a href="http://sailsjs.org" target="_blank" rel="noopener">Sails.js</a> 的时候，偶然看到了它使用的是 <a href="https://github.com/balderdashy/waterline" target="_blank" rel="noopener">Waterline</a> 来实现数据库的操作，发现它和 Sails.js 为同一团队所开发。翻了一下文档，感觉在中小型项目中使用，的确可以提升开发效率。</p><p>Java 中的 Hibernate 框架的一个重要功能便是将数据库中的数据与 Java 中的对象进行映射，被称为 ORM （Object Relational Mapping）。Node.js 里常用的 Mongoose ，便是将 MongoDB 的文档，映射为 JavaScript 的对象，而 Waterline 则是一个支持多种数据库的 Mongoose ，使得可以用一样的代码来实现对多种数据库的操作，无论是关系数据库还是文档数据库，都可以直接使用对象的方法来进行增删改查操作。<br><a id="more"></a></p><h3 id="功能与特点"><a href="#功能与特点" class="headerlink" title="功能与特点"></a>功能与特点</h3><ul><li><strong>广泛的数据库支持</strong>：支持几乎所有的主流关系数据库和文档数据库</li><li><strong>脱离 SQL </strong>：对于习惯了使用 Mongoose 的程序员，如果要去使用 SQL 操作关系数据库，肯定会有点费解， Waterline 可以像 Mongoose 一样使用对象的方法来实现关系数据库的操作</li><li><strong>屏蔽不同数据库的差别</strong>：对于大部分情况下，你根本不用关心操作的是 MySQL 还是 MongoDB。比如 MongoDB 中并没有数字自增（Auto Increment）的功能，但 Waterline 使用 <a href="https://github.com/balderdashy/waterline-docs/blob/1b17fbd12ce59b80bb4e53f197bacf0ca86a51d1/models/configuration.md#autopk" target="_blank" rel="noopener"><code>autoPK</code></a> 来为 MongoDB 实现了自增</li><li><strong>易于理解的符号</strong>：在 Mongoose 中，大于和小于得使用 <code>$gt</code> / <code>$lt</code> 来表示，而 Waterline 里，直接使用 <code>&gt;</code> / <code>&lt;</code> 即可</li><li><strong>多样的操作支持</strong>：提供了 26 种方法来进行增删改查操作</li><li><strong>丰富的数据类型</strong>：支持 JavaScipt 中除了对象外的所有数据类型，还额外提供了日期、时间、二进制、JSON的支持，数字还可以区分整数和浮点数</li></ul><h3 id="数据库的支持情况"><a href="#数据库的支持情况" class="headerlink" title="数据库的支持情况"></a>数据库的支持情况</h3><p>Waterline 里将操作数据库的方法翻译为具体的数据库查询语句的，叫适配器。分为两大类：</p><ul><li>官方团队提供的适配器：提供了对 MySQL / MongoDB / Redis 的支持</li><li>第三方开发的适配器：提供了对 PostgreSQL / Oracle / SQL Server / OrientDB / ArangoDB / Apache Cassandra 的支持</li></ul><p>基本上实现了对主流数据库的支持。</p><h3 id="配置中的适配器与连接"><a href="#配置中的适配器与连接" class="headerlink" title="配置中的适配器与连接"></a>配置中的适配器与连接</h3><p>Waterline 之所以可以使用一样的代码来操作多种数据库，奥妙<del>洗衣粉</del>在于其适配器。在进行配置的时候，需要设置两方面的内容，一是具体使用哪些适配器，二是建立数据库连接的时候，使用哪个适配器。下面是使用 MongoDB 的适配器创建一个数据库连接的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoAdapter = <span class="built_in">require</span>(<span class="string">'sails-mongo'</span>);</span><br><span class="line"><span class="keyword">var</span> wlconfig = &#123;</span><br><span class="line">  adapters: &#123;</span><br><span class="line">    <span class="string">'default'</span>: mongoAdapter,</span><br><span class="line">    <span class="string">'mongo'</span>: mongoAdapter</span><br><span class="line">  &#125;,</span><br><span class="line">  connections: &#123;</span><br><span class="line">    <span class="string">'mongo'</span>: &#123;</span><br><span class="line">      <span class="comment">// adapters 中的适配器代码</span></span><br><span class="line">      adapter: <span class="string">'mongo'</span>,</span><br><span class="line">      url: <span class="string">'mongodb://localhost/waterline-sample'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Waterline 在 MongoDB 的配置中，甚至还直接支持配置复制架构。</p><p>注意，需要在 <code>adapters</code> 中指定具体的适配器，<code>connections</code> 中配置连接时再指定 <code>adapters</code> 中的适配器代码。在进行具体的数据集合创建时，将会要指定使用 <code>connections</code> 中的哪个连接。</p><h3 id="数据集合"><a href="#数据集合" class="headerlink" title="数据集合"></a>数据集合</h3><p>Waterline 中负责具体与表和集合对应的是数据集合 Collection，它有点类似于 Mongoose 中的 Model，但在 Waterline 中，所有的数据集合合在一起，加上一些其它的属性和方法，构成一整个 <code>models</code>。</p><p>数据集合在初始化的时候，需要指定使用哪些连接，是否强制模式，具有哪些属性以及集合的 id，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Post = Waterline.Collection.extend(&#123;</span><br><span class="line">  <span class="comment">// 集合的 id</span></span><br><span class="line">  identity: <span class="string">'post'</span>,</span><br><span class="line">  <span class="comment">// 使用的连接数</span></span><br><span class="line">  connection: <span class="string">'mongo'</span>,</span><br><span class="line">  <span class="comment">// 是否强制模式</span></span><br><span class="line">  schema: <span class="literal">true</span>,</span><br><span class="line">  attributes: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="string">'string'</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    content: <span class="string">'string'</span>,</span><br><span class="line">    createTime: <span class="string">'date'</span>,</span><br><span class="line">    lastModifyTime: <span class="string">'date'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>配置相当简单方便，类似于 Mongoose 中的 Schema。但要注意，指定属性的字段时，使用的是一个字符串值，而不是 JavaScript 中的具体类型，目前支持的数据类型有 <code>string</code> / <code>text</code> / <code>integer</code> / <code>float</code> / <code>date</code> / <code>time</code> / <code>datetime</code> / <code>boolean</code> / <code>binary</code> / <code>array</code> / <code>json</code>，这个范围要比 JavaScript 的类型范围大。</p><p>除了这四个基本配置，还可以配置校验器，添加自定义的方法，设置生命周期回调方法等。</p><h3 id="校验器"><a href="#校验器" class="headerlink" title="校验器"></a>校验器</h3><p><a href="https://github.com/balderdashy" target="_blank" rel="noopener">balderdashy</a> 为了 Sails.js 创建了 Waterline，为了实现 Waterline 中的数据校验，又参与了 <a href="https://github.com/sailsjs/anchor" target="_blank" rel="noopener">Anchor</a> 的开发。</p><p>校验器是在创建数据集合的时候指定给具体的属性的，除了预定义的校验器，还可以自定义校验器。预定义的校验器涵盖了 Mongoose 中的必须字段验证、字符串长度验证等。比如下面这几种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Waterline.Collection.extend() 的参数之一</span></span><br><span class="line">attributes: &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    type: <span class="string">'string'</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    maxLength: <span class="number">100</span>,</span><br><span class="line">    minLength: <span class="number">5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  views: &#123;</span><br><span class="line">    type: <span class="string">'integer'</span>,</span><br><span class="line">    min: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  createTime: &#123;</span><br><span class="line">    type: <span class="string">'date'</span>,</span><br><span class="line">    <span class="comment">// 在某个时间点之前</span></span><br><span class="line">    before: <span class="string">'2100-12-31'</span>,</span><br><span class="line">    <span class="comment">// 在某个时间点之后</span></span><br><span class="line">    after: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面这几个简单的，<a href="https://github.com/sailsjs/anchor/blob/master/lib/match/rules.js" target="_blank" rel="noopener">Anchor 支持的验证器</a> 还有针对时间、地理位置、正则表达式、布尔值、Email地址的，一共有 20 多个，用过 Mongoose 验证器的人是不是已经泪流满面了？</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>Waterline 提供了 <a href="https://github.com/balderdashy/waterline#query-methods" target="_blank" rel="noopener">26 种查询方法</a> ——你没有看错，是 26 种。除了常规的 <code>find</code> / <code>create</code> / <code>update</code> / <code>destory</code> 方法，还有 <code>findLike</code> / <code>startWith</code> / <code>findByNameIn</code> / <code>nameContains</code> 之类。</p><p>查询方法可以使用三种方式来调用，分别是：</p><ul><li>回调方式：直接把结果处理函数以回调函数的方法传给查询方法</li><li>链式方式：查询方法之后，直接以链式方式依次组织各个查询接口</li><li>Promise：这一方式使得错误处理更漂亮，代码也更容易阅读</li></ul><p><a href="https://github.com/balderdashy/waterline-docs/blob/master/queries/query.md" target="_blank" rel="noopener">查询的接口</a>也很丰富，<code>where</code> / <code>sort</code> / <code>exec</code>，还有 Mongoose 中的 <code>populate</code> ，查询翻页使用 <code>limit</code> / <code>skip</code>，还提供了一个集成的方法 <code>paginate</code>，直接传入页码和每码数量即可。</p><p><a href="https://github.com/balderdashy/waterline-docs/blob/master/queries/query-language.md" target="_blank" rel="noopener">查询的语法</a>就更丰富了，包括：</p><ul><li><a href="https://github.com/balderdashy/waterline-docs/blob/master/queries/query-language.md#criteria-modifiers" target="_blank" rel="noopener">条件修饰符</a>：包括 <code>&gt;</code> / <code>&lt;</code> / <code>&gt;=</code> / <code>&lt;=</code> / <code>!</code> / <code>like</code> / <code>contains</code> / <code>startWith</code> / <code>endWith</code>，大小比较的，除了常规的数字，也支持时间</li><li><a href="https://github.com/balderdashy/waterline-docs/blob/master/queries/query-language.md#query-options" target="_blank" rel="noopener">查询选项</a>：提供了 <code>limit</code> / <code>skip</code> 两个属性组织分页，使用 <code>sort</code> 属性确定排序，排序即可以使用 SQL 语法里的 <code>DESC</code> / <code>ASC</code> ，也可以用对象的方式来直接指定排序标准，并支持指定多个排序标准。<code>select</code> 指定查询结果所包含的字段</li></ul><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>Mongoose 可以通过<a href="http://mongoosejs.com/docs/middleware.html" target="_blank" rel="noopener">中间件</a>，来实现在进行特定操作的时候，调用自定义的方法。Waterline 必然也有这个功能，叫<a href="https://github.com/balderdashy/waterline-docs/blob/master/models/lifecycle-callbacks.md" target="_blank" rel="noopener">生命周期回调（Lifecycle Callbacks）</a>，除了没有 Mongoose 中的 <code>init</code> ，在 <code>create</code> / <code>update</code> / <code>destory</code> 时，均有多种回调。不过，调用的方法与 Mongoose 稍有不同，Waterline 的生命周期回调，是直接提供对应的方法名，分别是：</p><ul><li>创建时：<code>beforeValidate</code> / <code>afterValidate</code> / <code>beforeCreate</code> / <code>afterCreate</code></li><li>更新时：<code>beforeValidate</code> / <code>afterValidate</code> / <code>beforeUpdate</code> / <code>afterUpdate</code></li><li>删除时：<code>beforeDestroy</code> / <code>afterDestroy</code></li></ul><p>这些方法，需要在初始化数据集合的时候进行定义。</p><h3 id="还有吗？"><a href="#还有吗？" class="headerlink" title="还有吗？"></a>还有吗？</h3><p>当然，Waterline 还支持<a href="https://github.com/balderdashy/waterline#custom-types" target="_blank" rel="noopener">自定义数据类型</a>、<a href="https://github.com/balderdashy/waterline-docs/blob/1b17fbd12ce59b80bb4e53f197bacf0ca86a51d1/models/data-types-attributes.md#index" target="_blank" rel="noopener">索引</a>和<a href="https://github.com/balderdashy/waterline-docs/blob/master/models/associations/associations.md" target="_blank" rel="noopener">集合间的关联</a>。</p><p>下篇文章，我将使用一个例子来展示如何在实际的项目中使用 Waterline。</p><p>@2015-10-27 update，新文章<a href="http://chensd.com/2015-10/Use-Waterline-in-Express-project.html">在 Express 项目中使用 Waterline </a>已经完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在看 &lt;a href=&quot;http://sailsjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sails.js&lt;/a&gt; 的时候，偶然看到了它使用的是 &lt;a href=&quot;https://github.com/balderdashy/waterline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Waterline&lt;/a&gt; 来实现数据库的操作，发现它和 Sails.js 为同一团队所开发。翻了一下文档，感觉在中小型项目中使用，的确可以提升开发效率。&lt;/p&gt;
&lt;p&gt;Java 中的 Hibernate 框架的一个重要功能便是将数据库中的数据与 Java 中的对象进行映射，被称为 ORM （Object Relational Mapping）。Node.js 里常用的 Mongoose ，便是将 MongoDB 的文档，映射为 JavaScript 的对象，而 Waterline 则是一个支持多种数据库的 Mongoose ，使得可以用一样的代码来实现对多种数据库的操作，无论是关系数据库还是文档数据库，都可以直接使用对象的方法来进行增删改查操作。&lt;br&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
      <category term="Waterline" scheme="http://chensd.com/tags/Waterline/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Mongoose 的实例方法中访问静态方法</title>
    <link href="http://chensd.com/2015-09/How-to-invoke-static-method-in-instance-method-of-mongoose.html"/>
    <id>http://chensd.com/2015-09/How-to-invoke-static-method-in-instance-method-of-mongoose.html</id>
    <published>2015-09-21T13:36:31.000Z</published>
    <updated>2021-03-10T23:07:38.714Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，在实例一个功能的时候，需要在实例方法中调用静态方法，查了一下 Mongoose 的文档，发现还真没有这方面的内容，不过 Google 了一下，还是在 <a href="http://stackoverflow.com/questions/14277518/how-to-access-a-static-method-from-a-instance-method-in-mongoose" target="_blank" rel="noopener">stackoverflow</a> 上找到了答案。</p><a id="more"></a><p>方法比较简单，也比较粗糙和丑陋，就是通过构造函数来访问静态方法，大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WorkSpaceSchema.methods.getPrice = <span class="function"><span class="keyword">function</span>(<span class="params">startTime, endTime</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> result = days * <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.constructor.getPricePerDay(<span class="keyword">this</span>.discountPrice || <span class="keyword">this</span>.price, <span class="keyword">this</span>.priceType));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WorkSpaceSchema.statics.getPricePerDay = <span class="function"><span class="keyword">function</span>(<span class="params">price, priceType</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到这个解决方案后，第一想法是，Mongoose 在设计的时候，为什么没有考虑方法之间的访问这一情形呢，仔细一想，静态方法的设计初衷，只是为了通过对 Model 已有方法进行扩充和自定义，创建出一些特别的搜索方法之类，而如果想要创建在其它方法中调用的方法，更好的解决办法是写单独的模块，然后再导出和调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，在实例一个功能的时候，需要在实例方法中调用静态方法，查了一下 Mongoose 的文档，发现还真没有这方面的内容，不过 Google 了一下，还是在 &lt;a href=&quot;http://stackoverflow.com/questions/14277518/how-to-access-a-static-method-from-a-instance-method-in-mongoose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stackoverflow&lt;/a&gt; 上找到了答案。&lt;/p&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 4.0.0 新特性：模板字符串（Template Strings）</title>
    <link href="http://chensd.com/2015-09/ES6-template-strings.html"/>
    <id>http://chensd.com/2015-09/ES6-template-strings.html</id>
    <published>2015-09-12T22:21:58.000Z</published>
    <updated>2021-03-10T23:07:38.713Z</updated>
    
    <content type="html"><![CDATA[<p>前两天<a href="https://nodejs.org/en/blog/release/v4.0.0/" target="_blank" rel="noopener">新发布的 Node.js 4.0.0 稳定版</a>，总算让 Node.js 用上了新的 V8 4.5，也使得 V8 中的 ECMAScript 6 新特性终于来到了 Node.js，除了引入注目的类型数据、箭头函数一类，还有个模板字符串（Template Strings），使得广大 Node.js 程序员可以用原生的方法来进行相对复杂的字符串处理了。</p><a id="more"></a><h3 id="蛮荒时代"><a href="#蛮荒时代" class="headerlink" title="蛮荒时代"></a>蛮荒时代</h3><p>在以前，如果要处理一个多行的字符串，你得：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \\n 是为了高亮插件的显示，实际应为 \n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'鹅，鹅，鹅，\\n\</span></span><br><span class="line"><span class="string">曲项向天歌。\\n\</span></span><br><span class="line"><span class="string">白毛浮绿水，\\n\</span></span><br><span class="line"><span class="string">红掌拨清波。'</span>);</span><br></pre></td></tr></table></figure><p>当然，老成一点的，还知道可以用数组进行组合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">'鹅，鹅，鹅，'</span>,</span><br><span class="line"><span class="string">'曲项向天歌。'</span>,</span><br><span class="line"><span class="string">'白毛浮绿水，'</span>,</span><br><span class="line"><span class="string">'红掌波清波。'</span>].join(<span class="string">'\\n'</span>));</span><br></pre></td></tr></table></figure><p>那如果要在字符串中插入变量呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'Sid'</span>, <span class="attr">location</span>: <span class="string">'Shanghai'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'person: '</span> + <span class="built_in">JSON</span>.stringify(person) + <span class="string">' is here'</span>);</span><br><span class="line"><span class="comment">// person:&#123;"name":"Sid","location":"Shanghai"&#125; is here</span></span><br></pre></td></tr></table></figure><p>或者这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'person:'</span>, person, <span class="string">'is here'</span>);</span><br><span class="line"><span class="comment">// person: &#123; name: 'Sid', location: 'Shanghai' &#125; is here</span></span><br></pre></td></tr></table></figure></p><p>没错，一个都没让人省心。</p><h3 id="闪亮登场"><a href="#闪亮登场" class="headerlink" title="闪亮登场"></a>闪亮登场</h3><p>模板字符串出场了，它就是为了解决上面这些问题。与变通字符串使用单双引号来包裹值不一样，模板字符串用的是’`‘，可以随意组织多行数据而不加入任何特殊符号，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`  鹅，鹅，鹅，</span></span><br><span class="line"><span class="string">  曲项向天歌。</span></span><br><span class="line"><span class="string"> 白毛浮绿水，</span></span><br><span class="line"><span class="string">红掌波清波。`</span>);</span><br></pre></td></tr></table></figure><p>既然称之为模板，当然也就具有模板的一些功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameHe = <span class="string">'Li Lei'</span>, nameShe = <span class="string">'Han Meimei'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">  this is <span class="subst">$&#123;nameHe&#125;</span>, </span></span><br><span class="line"><span class="string">  this is <span class="subst">$&#123;nameShe&#125;</span>`</span></span><br><span class="line">  , nameHe);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  this is Li Lei, </span></span><br><span class="line"><span class="comment">  this is Han Meimei Li Lei</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>还可以直接执行表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intA = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Math.sqrt(3):<span class="subst">$&#123;<span class="built_in">Math</span>.sqrt(<span class="number">3</span>)&#125;</span>, intA^2: <span class="subst">$&#123;intA * intA&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Math.sqrt(3):1.7320508075688772, intA^2: 100</span></span><br></pre></td></tr></table></figure><p>此外，可以组织一个函数，来专门处理模版字符串，类似于这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taggedTS</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arguments:'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taggedTS <span class="string">`This is <span class="subst">$&#123;intA&#125;</span> and sqrt: <span class="subst">$&#123;<span class="built_in">Math</span>.sqrt(intA)&#125;</span>`</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: &#123; '0': [ 'This is ', ' and sqrt: ', '' ],</span></span><br><span class="line"><span class="comment">  '1': 10,</span></span><br><span class="line"><span class="comment">  '2': 3.1622776601683795 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意，虽然看起来像个普通的函数，但在调用的时候，不能使用括号，而是直接用函数名加模板字符串的方式。传入的参数，分为两部分，第一个是被动态的值所分隔的多个字符串，后面是对应的各个动态值的计算结果。</p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>与SQL注入一样，如果要把用户的输入直接作为模板字符串的内容，务必先进行仔细的检查，因为恶意的输入者，可能会通过猜测变量名，来获取你程序中比较危险的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天&lt;a href=&quot;https://nodejs.org/en/blog/release/v4.0.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新发布的 Node.js 4.0.0 稳定版&lt;/a&gt;，总算让 Node.js 用上了新的 V8 4.5，也使得 V8 中的 ECMAScript 6 新特性终于来到了 Node.js，除了引入注目的类型数据、箭头函数一类，还有个模板字符串（Template Strings），使得广大 Node.js 程序员可以用原生的方法来进行相对复杂的字符串处理了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中的分页、标签、分类链接地址错误问题</title>
    <link href="http://chensd.com/2015-09/Hexo-Relative-Link-Problems.html"/>
    <id>http://chensd.com/2015-09/Hexo-Relative-Link-Problems.html</id>
    <published>2015-09-11T22:16:54.000Z</published>
    <updated>2021-03-10T23:07:38.714Z</updated>
    
    <content type="html"><![CDATA[<p>从 Wordpress 迁移到 Hexo 已经有半年多的时间了，但有一个问题一直困扰着我没有解决，那就是站点上很多链接的 href 值都有问题，链接点击后会到一些根本不存在的或错误的页面，比如：</p><ul><li>分页链接：本来 href 的值应该是 <code>/page/2/index.html</code> 之类，但它的目标地址却是不存在的 <code>/page/index.html</code> ，于是就 404 了</li><li>分类链接：本来 href 的值应该是 <code>/categories/建站相关/index.html</code> 之类，但却是的 <code>/categories/index.html</code> ，于是不论怎么点，都还是在分类首页中</li><li>标签链接：本来 href 的值应该是 <code>/tags/Hexo/index.html</code> 之类，但却和分类链接一样，直接链到了 <code>/tags/inddex.html</code></li></ul><p>昨天早上的时候，我终于决定，无论如何要找到原因。</p><a id="more"></a><p>最开始我怀疑的是主题的问题，仔细看了好几个相关的问题，并没有发现任何直接写链接的代码。又更换了主题，问题依然存在，于是便排除主题的原因。</p><p>我把所有的 <code>source/_posts</code> 中的文件复制到一个完全新建的 Hexo 站点中来，只做最简单的配置，运行起来后，发现所有的链接完全正常。于是复制进来主题目录，依然是正常的。再复制站点的 <code>_config.yml</code> 文件——这下便不正常了。</p><p>接着就简单了，一个一个找具体是哪一个配置有问题。几次尝试，终于发现了罪魁祸首——原来是相对链接的配置项：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">relative_link:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我最开始使用的是 Hexo 2.x ，可能那时候默认的 <code>relative_link</code> 配置是 <code>true</code>，而 3.x 中已经默认将其设置为 <code>false</code> ，在 3.x 中，Hexo 的相对链接处理，是有 bug 的。于是便导致了这些问题。</p><p>已经有人在大前天提了个 <a href="https://github.com/hexojs/hexo/issues/1381" target="_blank" rel="noopener">issue</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 Wordpress 迁移到 Hexo 已经有半年多的时间了，但有一个问题一直困扰着我没有解决，那就是站点上很多链接的 href 值都有问题，链接点击后会到一些根本不存在的或错误的页面，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分页链接：本来 href 的值应该是 &lt;code&gt;/page/2/index.html&lt;/code&gt; 之类，但它的目标地址却是不存在的 &lt;code&gt;/page/index.html&lt;/code&gt; ，于是就 404 了&lt;/li&gt;
&lt;li&gt;分类链接：本来 href 的值应该是 &lt;code&gt;/categories/建站相关/index.html&lt;/code&gt; 之类，但却是的 &lt;code&gt;/categories/index.html&lt;/code&gt; ，于是不论怎么点，都还是在分类首页中&lt;/li&gt;
&lt;li&gt;标签链接：本来 href 的值应该是 &lt;code&gt;/tags/Hexo/index.html&lt;/code&gt; 之类，但却和分类链接一样，直接链到了 &lt;code&gt;/tags/inddex.html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;昨天早上的时候，我终于决定，无论如何要找到原因。&lt;/p&gt;
    
    </summary>
    
      <category term="建站相关" scheme="http://chensd.com/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Hexo" scheme="http://chensd.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>译作《 MEAN Web 开发》中文版发行</title>
    <link href="http://chensd.com/2015-09/MEAN-Web-Development-CN-published.html"/>
    <id>http://chensd.com/2015-09/MEAN-Web-Development-CN-published.html</id>
    <published>2015-09-10T21:31:50.000Z</published>
    <updated>2021-03-10T23:07:38.714Z</updated>
    
    <content type="html"><![CDATA[<p>两年前的时候，我没想到自己会成为一名 JavaScript 程序员，正如七年前，我没有想到自己会翻译别人的书一样。08年的时候，当拿到编写的第一本书的样书时，发现依然有那么多处错误，后来看到莱辛的名言：一本书，就是一大宗罪，深以为然。后来别人联系编写一本类似主题的书时，我便回绝了。</p><p>去年十月，在微博上看到李松峰老师发布的出版计划，其中包括 <em>MEAN Web Development</em> ，没办法，与我现在使用的主要的技术栈实在是太切合了，于是发送了请求试译的邮件，很快也收到了同意的回复，在女友的帮助下，试译也非常的顺利，拿到了翻译合同。前后大约花了四个月的周末，终于翻译完成。</p><p>翻译工作比我想像得要麻烦，好在图灵提供的写作平台工具还不错，编辑与作者之前的协作也比较融洽。因此整体上，还是比较顺利的。</p><p>这次翻译工作，对我个人来讲，最大的变化就是考虑完全迁移到使用 Markdown 格式。受此影响，博客也从 Wordpress 换到了 Hexo ，从使用情况来看，的确是可以将处理文档的精力全部放在内容上——至少，我终于又开始更新博客了。</p><p>书的封面动物，是一只<a href="https://zh.wikipedia.org/zh-cn/%E7%81%AB%E7%83%88%E9%B8%9F" target="_blank" rel="noopener">火烈鸟</a>——当然是通过 Google 图片搜索才知道的，</p><p>新书信息：<a href="http://chensd.com/books">http://chensd.com/books</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两年前的时候，我没想到自己会成为一名 JavaScript 程序员，正如七年前，我没有想到自己会翻译别人的书一样。08年的时候，当拿到编写的第一本书的样书时，发现依然有那么多处错误，后来看到莱辛的名言：一本书，就是一大宗罪，深以为然。后来别人联系编写一本类似主题的书时，我便
      
    
    </summary>
    
      <category term="翻译" scheme="http://chensd.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
      <category term="翻译" scheme="http://chensd.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket的性能与压力测试</title>
    <link href="http://chensd.com/2015-07/websocket-stress-test-and-performance-test.html"/>
    <id>http://chensd.com/2015-07/websocket-stress-test-and-performance-test.html</id>
    <published>2015-07-30T09:22:09.000Z</published>
    <updated>2021-03-10T23:07:38.741Z</updated>
    
    <content type="html"><![CDATA[<p>相对于短连接应用，长连接应用的测试要麻烦得多——尤其是性能和压力测试。此前，甚至从来没有给任何一个上线的 WebSocket 应用做过这方面的测试，前两天，看到有人在 <a href="http://segmentfault.com/q/1010000003028043" target="_blank" rel="noopener">SegmentFault 上问</a>这方面的问题，刚好又有空，于是想着，还是来查查这方面的资料吧。在 Github 上一搜，还真有现成的工具，名字很简单，直接就叫<a href="https://github.com/M6Web/websocket-bench" target="_blank" rel="noopener">websocket-bench</a>，</p><p>websocket-bench 是个用 Node.js 编写的命令行工具，可以对使用 Socket.io、<a href="https://github.com/faye/faye" target="_blank" rel="noopener">faye</a>、<a href="https://github.com/primus/primus" target="_blank" rel="noopener">Primus</a>、<a href="https://github.com/tavendo/WAMP" target="_blank" rel="noopener">WAMP</a> 编写的长连接应用进行性能和压力测试，用法和参数与 ab 差不多，多了一个指定连接成功后进行的操作的定义。</p><a id="more"></a><h3 id="websocket-bench-安装"><a href="#websocket-bench-安装" class="headerlink" title="websocket-bench 安装"></a>websocket-bench 安装</h3><p>需要使用 npm 以全局的方式来安装 websocket-bench，当然要用阿里提供的<a href="http://npm.taobao.org" target="_blank" rel="noopener">]福利服务器</a>，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g websocket-bench --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>这里以在 CentOS 6.5 上进行测试为便进行说明。首先要修改一下文件打开数，默认是1024，修改为一个比较大的值就行，总共65535个端口，我们测试也不会用太大的并发，websocket-bench 推荐设置的是 60000 ，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 60000</span><br></pre></td></tr></table></figure><p>websocket-bench 的参数与 ab 基本一致，像这样</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocket-bench -a 300 -c 29 http://localhost:8100 -o opt.log</span><br></pre></td></tr></table></figure><p><code>-a</code> 参数用于指定总共的测试次数，<code>-c</code>参数指定并发连接数。我这里测试的是一个 Socket.io 的服务器，所以不需要使用 <code>-t</code>参数指定类型，如果是其它的，则需要使用 <code>engine.io</code> <code>faye</code> <code>primus</code> <code>wamp</code> 进行指定。运行完成后，会打印报告，报告分两小部分，前一部分是以 <code>-c</code> 指定的数量组织的表格，后一部分是整个测试的统计，数据包括错误数和消耗时间。</p><p>使用<code>-o</code>参数可以将报告保存到单独的文件中。</p><h3 id="使用-generator-来自定义测试逻辑"><a href="#使用-generator-来自定义测试逻辑" class="headerlink" title="使用 generator 来自定义测试逻辑"></a>使用 generator 来自定义测试逻辑</h3><p>长连接压力测试麻烦的一部分，就在于连接完成后需要完成一定的交互操作，websocket-bench 通过 <code>generator</code> 文件来方便测试人员编写连接上服务器后所需要执行的操作。下面是我为了简单的测试一个2D地图移动游戏的简单测试文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//可选，在建立连接之前会执行</span></span><br><span class="line">  beforeConnect: <span class="function"><span class="keyword">function</span>(<span class="params">client</span>)</span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//必选，建立连接后所要做的事情</span></span><br><span class="line">  onConnect: <span class="function"><span class="keyword">function</span>(<span class="params">client, done</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="comment">//client 为客户端的连接实例</span></span><br><span class="line">    client.emit(<span class="string">'setTitle'</span>, &#123;<span class="attr">title</span>: <span class="string">'bench_'</span> + randomNumber(), <span class="attr">pVer</span>: <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    done();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//必选，向服务器民送消息时运行的代码</span></span><br><span class="line">  sendMessage: <span class="function"><span class="keyword">function</span>(<span class="params">client, done</span>) </span>&#123;</span><br><span class="line">    client.emit(<span class="string">'moveTo'</span>, &#123;<span class="attr">x</span>: randomNumber(<span class="number">3500</span>), <span class="attr">y</span>: randomNumber(<span class="number">3500</span>)&#125;);</span><br><span class="line">    done();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNumber</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()* (max || <span class="number">100000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完成后，在运行 websocket-bench 时，使用 <code>-g</code> 参数指定 generator 文件即可。</p><p>另外，测试的时候，可以使用 <a href="http://iptraf.seul.org/" target="_blank" rel="noopener">iptraf</a> 工具来看看带宽的占用情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对于短连接应用，长连接应用的测试要麻烦得多——尤其是性能和压力测试。此前，甚至从来没有给任何一个上线的 WebSocket 应用做过这方面的测试，前两天，看到有人在 &lt;a href=&quot;http://segmentfault.com/q/1010000003028043&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SegmentFault 上问&lt;/a&gt;这方面的问题，刚好又有空，于是想着，还是来查查这方面的资料吧。在 Github 上一搜，还真有现成的工具，名字很简单，直接就叫&lt;a href=&quot;https://github.com/M6Web/websocket-bench&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;websocket-bench&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;websocket-bench 是个用 Node.js 编写的命令行工具，可以对使用 Socket.io、&lt;a href=&quot;https://github.com/faye/faye&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;faye&lt;/a&gt;、&lt;a href=&quot;https://github.com/primus/primus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Primus&lt;/a&gt;、&lt;a href=&quot;https://github.com/tavendo/WAMP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMP&lt;/a&gt; 编写的长连接应用进行性能和压力测试，用法和参数与 ab 差不多，多了一个指定连接成功后进行的操作的定义。&lt;/p&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Angular2路由模块简介</title>
    <link href="http://chensd.com/2015-06/Angular-New-Router.html"/>
    <id>http://chensd.com/2015-06/Angular-New-Router.html</id>
    <published>2015-06-07T07:19:08.000Z</published>
    <updated>2021-03-10T23:07:38.712Z</updated>
    
    <content type="html"><![CDATA[<p><strong>由于该模块已经停止针对 AngularJS 1.4.7 及以下版本的维护，请不要再在项目中使用。</strong></p><p>Angular2虽然还没有正式发布，但全新设计的路由模块已经提前面世，它从AngularJS 1.4开始支持。相对于老的<code>ngRoute</code>，使用更方便，配置更简单，更加注重约定。新的路由模块被命名为<a href="https://github.com/angular/router" target="_blank" rel="noopener">Angualar New Router</a>，以前的<code>ui-view</code>被新的<code>ng-viewport</code>取而代之，另外引入了<code>component</code>的概念。我们用一个例子来对它做一个简单的了解。</p><p>先放<a href="https://coding.net/u/Stiekel/p/static/git/tree/master/public/angular-new-router" target="_blank" rel="noopener">代码</a>和<a href="http://stiekel.coding.io/angular-new-router/#/" target="_blank" rel="noopener">DEMO</a>。</p><a id="more"></a><h3 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h3><p>先来构建基础的HTML和JS代码，<a href="https://coding.net/u/Stiekel/p/static/git/blob/master/public/angular-new-router/index.html" target="_blank" rel="noopener">index.html</a>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Angular New Router Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">"webApp"</span> <span class="attr">ng-controller</span>=<span class="string">"AppController as app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ng-viewport</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-viewport</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/angular2/angular.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/angular-new-router/dist/router.es5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是AngularJS基础代码，<a href="https://coding.net/u/Stiekel/p/static/git/blob/master/public/angular-new-router/app.js" target="_blank" rel="noopener">app.js</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">angular.module(<span class="string">'webApp'</span>, [<span class="string">'ngNewRouter'</span>])</span><br><span class="line">  .controller(<span class="string">'AppController'</span>, [<span class="string">'$router'</span>, AppController]);</span><br><span class="line"></span><br><span class="line">AppController.$routeConfig = [</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppController</span> (<span class="params">$router</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构件component"><a href="#构件component" class="headerlink" title="构件component"></a>构件<code>component</code></h3><p>AngularJS 1.3之前，在配置一个路由页面时，一般会包括一个HTML模板，一个控制器和一套路由配置。路由配置中，要指定相应的HTML模板和控制器名称。在新的路由策略中，这些被构件（<code>component</code>）所取代，一个构件包括以下几部分：</p><ul><li>独立的目录，目录名就是构件名</li><li>目录内，与目录同名的一个js文件，用它来存储模块和控制器代码</li><li>目录内，与目录同名的HTML文件</li></ul><p>比如，像下面这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">home/</span><br><span class="line">├── home.html</span><br><span class="line">└── home.js</span><br></pre></td></tr></table></figure><p>单从上面这几部分来讲，可能看不出来构件的优势，但在路由配置的时候，你根本不用指定HTML文件，也不用指定控制器名字，只需要直接使用构件名——也就是目录名就行了。像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'home'</span>&#125;</span><br></pre></td></tr></table></figure><p>配置的代码简化了许多，而你所需要做的，就是遵循约定，使用约定来取代配置。先来看看<code>home.js</code>文件，它包括控制器和模块代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'webApp.home'</span>, [])</span><br><span class="line">  .controller(<span class="string">'HomeController'</span>, [<span class="string">"$router"</span>, HomeController]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomeController</span>(<span class="params">$router</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.AppName = <span class="string">'Angular New Router示例'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于不再<code>$scope</code>满天飞了，控制器更符合面向对象的概念，使用了<code>this</code>。以前在HTML中，是直接使用控制器内的变量，再在，需要指定构件名了，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;home.AppName&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>构件的js文件，需要使用<code>&lt;script&gt;</code>来导入，另外还要在<code>app.js</code>的主模块中，加入对构件模块的依赖，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'webApp'</span>,</span><br><span class="line">    [<span class="string">'ngNewRouter'</span>, <span class="string">'webApp.home'</span>, <span class="string">'webApp.articles'</span>]</span><br><span class="line">  )</span><br><span class="line">  .controller(<span class="string">'AppController'</span>, [<span class="string">'$router'</span>, AppController]);</span><br></pre></td></tr></table></figure><p>在上面的<code>index.html</code>文件中，曾经为BODY元素指定了控制器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">"webApp"</span> <span class="attr">ng-controller</span>=<span class="string">"AppController as app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要使用<code>AppController</code>中的变量，则需要像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;app.AppName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由的配置"><a href="#路由的配置" class="headerlink" title="路由的配置"></a>路由的配置</h3><p><code>ngRoute</code>中的路由配置，结构还是比较复杂的——反正我每次都是从现成的路由配置文件复制过来，不然可真记不住。但新的路由模块配置，相当简单方便，其实刚刚我们已经看过一行了，再来看看完整的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppController.$routeConfig = [</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'home'</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>没错，直接设置控制器的属性就行了。还可以在控制器代码内配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppController</span>(<span class="params">$router</span>) </span>&#123;</span><br><span class="line">  $router.config([</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/index'</span>, <span class="attr">redirectTo</span>: <span class="string">'/'</span>&#125;</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前的<code>url</code>属性，现在叫<code>path</code>了，单从字面意思上讲，其实用<code>path</code>更准确。如果要设置某个路由直接跳转到另外一个，使用<code>redirectTo</code>即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppController.$routeConfig = [</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'home'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/index'</span>, <span class="attr">redirectTo</span>: <span class="string">'/'</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>当然，你也可以直接设置别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: <span class="string">'home'</span>, <span class="attr">as</span>: <span class="string">'home'</span>&#125;</span><br></pre></td></tr></table></figure><p>基本上，一个路由只需要一条无需换行的代码便可以配置完成了。</p><h3 id="指向路由的链接"><a href="#指向路由的链接" class="headerlink" title="指向路由的链接"></a>指向路由的链接</h3><p><code>ngRoute</code>中是使用<code>ui-sref</code>来创建链接，现在增加了一个<code>ng-link</code>，虽然名字变了，但用法其实差不多，使用如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">ng-link</span>=<span class="string">'index'</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span>&gt;</span>Angular2的路由<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ng-viewport"><a href="#ng-viewport" class="headerlink" title="ng-viewport"></a><code>ng-viewport</code></h3><p>实在不知道这个<code>viewport</code>怎么个翻译，查了下<a href="http://dict.youdao.com/search?q=viewport" target="_blank" rel="noopener">有道</a>，居然叫视口——好吓人的感觉。</p><p>其实，它和以前的<code>ui-view</code>差不多，用法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-viewport</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-viewport</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-viewport</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-viewport</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这三种都行。最后一种用于有多个构件需要加载的情况。</p><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>路由参数和以前相比，没什么变化，它在路由中的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">'/articles/:id'</span>, <span class="attr">component</span>: <span class="string">'articles'</span>&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，也还是使用<code>$routeParams</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'webApp.articles'</span>, [])</span><br><span class="line">  .controller(<span class="string">"ArticlesController"</span>, [<span class="string">'$routeParams'</span>, <span class="string">'$router'</span>, ArticlesController]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArticlesController</span>(<span class="params">$routeParams, $router</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = $routeParams.id || <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接的格式也没有变化，仍然使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ng-link</span>=<span class="string">'articles(&#123;id: 1&#125;)'</span>&gt;</span>AngularJS常用插件与指令收集<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打完收功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;由于该模块已经停止针对 AngularJS 1.4.7 及以下版本的维护，请不要再在项目中使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Angular2虽然还没有正式发布，但全新设计的路由模块已经提前面世，它从AngularJS 1.4开始支持。相对于老的&lt;code&gt;ngRoute&lt;/code&gt;，使用更方便，配置更简单，更加注重约定。新的路由模块被命名为&lt;a href=&quot;https://github.com/angular/router&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angualar New Router&lt;/a&gt;，以前的&lt;code&gt;ui-view&lt;/code&gt;被新的&lt;code&gt;ng-viewport&lt;/code&gt;取而代之，另外引入了&lt;code&gt;component&lt;/code&gt;的概念。我们用一个例子来对它做一个简单的了解。&lt;/p&gt;
&lt;p&gt;先放&lt;a href=&quot;https://coding.net/u/Stiekel/p/static/git/tree/master/public/angular-new-router&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码&lt;/a&gt;和&lt;a href=&quot;http://stiekel.coding.io/angular-new-router/#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DEMO&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Safari 中转换 &#39;YYYY-M-D&#39; 格式时间的一个坑</title>
    <link href="http://chensd.com/2015-06/safari-date-parse.html"/>
    <id>http://chensd.com/2015-06/safari-date-parse.html</id>
    <published>2015-06-01T22:19:09.000Z</published>
    <updated>2021-03-10T23:07:38.738Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在微信开发的时候，遇到一个时间转换的坑，具体发现过程有多曲折就不说了。最终发现原因是，iOS 的 Sarari ——当然包括微信内置浏览器——在转换时间时，对 <code>YYYY-M-D</code> 的支持与 Chrome 和 Firefox 不一样。具体请看这个 <a href="http://chensd.com/code/safariDateParse.html">Demo</a>。</p><p>由于 <code>YYYY-MM-DD</code> 并不是标准的时间格式，ECMA 并没有对它的转换进行规定，所以具体转换就看各个引擎的实现了，不过几个主要的浏览器都支持了这个格式，但对 <code>YYYY-M-D</code> 的支持就不统一了。Firefox 是支持的，所以 Chrome 也就支持了。但 Safari 就……</p><p>建议：</p><ul><li>尽量不要使用 <code>YYYY-M-D</code> 格式的时间来进行转换，显示也要避免</li><li>使用第三方库来操作时间转换，比如 <a href="https://github.com/datejs/Datejs" target="_blank" rel="noopener">Datejs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天在微信开发的时候，遇到一个时间转换的坑，具体发现过程有多曲折就不说了。最终发现原因是，iOS 的 Sarari ——当然包括微信内置浏览器——在转换时间时，对 &lt;code&gt;YYYY-M-D&lt;/code&gt; 的支持与 Chrome 和 Firefox 不一样。具体请看这个 
      
    
    </summary>
    
      <category term="随手记" scheme="http://chensd.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS常用插件与指令收集</title>
    <link href="http://chensd.com/2015-06/AngularJS-popular-Plugins-and-Directive.html"/>
    <id>http://chensd.com/2015-06/AngularJS-popular-Plugins-and-Directive.html</id>
    <published>2015-06-01T10:21:23.000Z</published>
    <updated>2021-03-10T23:07:38.712Z</updated>
    
    <content type="html"><![CDATA[<p>使用AngularJS有差不多一年时间了，前前后后也用了不少库和指令，整理了一下，分成四大类列出。有demo地址的，就直接连接到demo地址，其它的直接链到github托管库中。</p><h3 id="图片视频类"><a href="#图片视频类" class="headerlink" title="图片视频类"></a>图片视频类</h3><ul><li><a href="http://passy.github.io/angular-masonry/" target="_blank" rel="noopener">angular-maxonry</a> 图片墙效果插件，可以将图片组织成类似于瀑布流的效果，依赖于jQuery、<a href="http://imagesloaded.desandro.com/" target="_blank" rel="noopener">imageloaded</a>和<a href="http://masonry.desandro.com/" target="_blank" rel="noopener">Masonry</a></li><li><a href="http://andrekoenig.info/angular-deckgrid/#/" target="_blank" rel="noopener">angular-deckgrid</a> 另一个照片瀑布流解决方案</li><li><a href="https://github.com/alexk111/ngImgCrop" target="_blank" rel="noopener">ngImgCrop</a> 图片剪裁工具</li><li><a href="https://github.com/Wildhoney/ngVideo" target="_blank" rel="noopener">ngVideo</a> 播放器，直接播放指定地址的mp4，控制按钮美观度远甩朝内99.99%的视频站</li><li><a href="https://github.com/stiekel/angular-image-404" target="_blank" rel="noopener">angular-image-404</a> 当 <code>img</code> 元素的图片无法正常获取时，使用这个指令可以显示占位图片，可以自定义占位图，也可以使用默认的占位图</li></ul><h3 id="输入控件类"><a href="#输入控件类" class="headerlink" title="输入控件类"></a>输入控件类</h3><ul><li><a href="https://github.com/fatlinesofcode/ngDraggable" target="_blank" rel="noopener">ngDraggable</a> 控制元素拖动的控件，<a href="http://htmlpreview.github.io/?https://github.com/fatlinesofcode/ngDraggable/blob/master/example.html" target="_blank" rel="noopener">Demo</a></li><li><a href="https://github.com/angular-ui/ui-sortable/" target="_blank" rel="noopener">ui-sortable</a> 以拖动的方式调整数组中元素的索引和位置，依赖 jQuery 和 jQuery-ui。<a href="http://angular-ui.github.io/ui-sortable/" target="_blank" rel="noopener">Demo</a></li><li><a href="https://github.com/wpalahnuk/ngAutocomplete" target="_blank" rel="noopener">ngAutocomplete</a> 喜闻乐见的自动补完</li><li><a href="http://textangular.com/" target="_blank" rel="noopener">textAngular</a> 文本编辑器，更简洁，更漂亮</li><li><a href="http://mbenford.github.io/ngTagsInput/" target="_blank" rel="noopener">ngTagsInput</a> 以标签的方式来组织输入</li><li><a href="http://prajwalkman.github.io/angular-slider/" target="_blank" rel="noopener">Angular-slider</a> 以拖动方式输入值的控件</li><li><a href="http://itslenny.github.io/angular-slidezilla/" target="_blank" rel="noopener">Angular Slidezilla</a> 与Angular-slider功能一样，只不过设计风格不一样</li><li><a href="https://vitalets.github.io/checklist-model/" target="_blank" rel="noopener">Checklist-model</a> AngularJS 多选框输入的值处理得并不好，通过这个指令，可以方便的将多选框的值直接组织成数组</li></ul><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><ul><li><a href="https://github.com/fraywing/textAngular" target="_blank" rel="noopener">textAngular</a> 在 Github 中排名第一的 HTML 编辑器， <a href="http://textangular.com/" target="_blank" rel="noopener">Demo</a>（需翻墙）</li><li><a href="https://www.froala.com/wysiwyg-editor" target="_blank" rel="noopener">Angular Froala</a> 非常好用的另外一个 HTML 编辑器，而且支持 inline 编辑，比 textAngular 漂亮，<a href="https://github.com/froala/angular-froala" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/YinChangSheng/angular-umeditor" target="_blank" rel="noopener">angular-umeditor</a> 百度umeditor的AngularJS扩展，umeditor从界面上讲并不够现代化，但却总有人喜欢它</li></ul><h3 id="界面类"><a href="#界面类" class="headerlink" title="界面类"></a>界面类</h3><ul><li><a href="https://angular-ui.github.io/bootstrap/" target="_blank" rel="noopener">ui-bootstrap</a> 官方扩展，在AngularJS中方便的以指令的方式使用<a href="http://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap</a></li><li><a href="http://angular-ui.github.io/ui-map/" target="_blank" rel="noopener">ui-map</a> 用于在页面中集成Google Maps</li><li><a href="http://angular-ui.github.io/ng-grid/" target="_blank" rel="noopener">NG-Grid</a> 官方提供的表格插件，支持表格的主题、排序、直接编辑、多行选择等操作，而且使用非常简单，只需要一行HTML代码，但是，比较难看，适合于不讲究外观但要求功能强大的场合，像后台工具、管理系统之类</li><li><a href="http://samu.github.io/angular-table/examples/examples.html" target="_blank" rel="noopener">angular-table</a> 第三方表格工具，适合于需要对表格进行高度定制的场合</li><li><a href="http://ng-table.com/#/" target="_blank" rel="noopener">ng-table</a> 在易用性和外观上对上面两个进行折衷的解决方案</li><li><a href="https://angular-ui.github.io/" target="_blank" rel="noopener">AngularUI</a> 上面的ui-bootstrap、ui-map就是它的一部分，官方提供的常用扩展集，除了这两个，还有ui-router、ui-select等，注意，它使用的是Bootstrap 2.x</li><li><a href="http://adaptv.github.io/adapt-strap/" target="_blank" rel="noopener">Adapt-Strap</a> 第三方Bootstrap插件，而且是基于扁平化的Bootstrap 3，更美观</li><li><a href="https://gabiaxel.github.io/ng-polymer-elements/" target="_blank" rel="noopener">ng-polymer-elements</a> <a href="https://www.polymer-project.org/1.0/" target="_blank" rel="noopener">Polymer</a>风格的AngularJS指令，Material Design设计，值得尝试</li><li><a href="http://chieffancypants.github.io/angular-loading-bar/" target="_blank" rel="noopener">Angular Loading Bar</a> 可用于在页面顶部增加一个漂亮的进度条</li><li><a href="http://ngmodules.org/modules/angular-busy" target="_blank" rel="noopener">angular-busy</a> 与Angular Loading Bar有点类似，主要用于处理$http通信时候的动画</li><li><a href="http://ngmodules.org/modules/ngInfiniteScroll" target="_blank" rel="noopener">ngInfiniteScroll</a> 从名字可以看出来，它是一个用于组织瀑布流和时间线的扩展</li><li><a href="https://github.com/iameugenejo/ngScrollTo" target="_blank" rel="noopener">ngScrollTo</a> 页内滚动工具，可以将页面滚动到指定id的元素位置</li><li><a href="http://likeastore.github.io/ngDialog/#" target="_blank" rel="noopener">ngDialog</a> 比Bootstrap更简单，更好用，更漂亮的网页对话框</li><li><a href="https://github.com/eu81273/angular.treeview" target="_blank" rel="noopener">Angular Treeview</a> 树状目录组织扩展，使用相当方便，而且不依赖于jQuery</li><li><a href="https://github.com/Marcorinck/angular-growl" target="_blank" rel="noopener">angular-growl</a> 用于在页面上显示警告框，可以设置显示时间，还可以直接显示$http中收到的警告</li><li><a href="http://sparkalow.github.io/angular-truncate/" target="_blank" rel="noopener">angular-truncate</a> 当文字过多过长时，显示部分文字的插件，可以按文字总长度来控制，也可以按单词数量来控制</li><li><a href="https://github.com/sebasrodriguez/angular-fallback-image" target="_blank" rel="noopener">angular-fallback-image</a> 当你的图片地址返回的是 404 的时候，使用这个插件可以将其替换为另外的占位图</li></ul><h3 id="其它工具类"><a href="#其它工具类" class="headerlink" title="其它工具类"></a>其它工具类</h3><ul><li><a href="https://angular-translate.github.io/" target="_blank" rel="noopener">angular-translate</a> AngularJS的i18n扩展</li><li><a href="https://satellizer.herokuapp.com/" target="_blank" rel="noopener">Satellizer</a> 可以方便的在AngularJS中集成第三方账号登录，支持国际主流社交网站账号，支持协议有OAuth 1.0/2.0</li><li><a href="https://github.com/gsklee/ngStorage" target="_blank" rel="noopener">ngStorage</a> 本在存储插件，用于处理localStorage和sessionStorage</li><li><a href="https://github.com/asafdav/ng-csv" target="_blank" rel="noopener">ng-csv</a> 导出csv的扩展</li><li><a href="https://github.com/tadeuszwojcik/angular-once" target="_blank" rel="noopener">angular-once</a> 双向绑定虽然方便，但如果数据太多，会造成一些性能问题。<code>angular-once</code>的解决方案是，对于不涉及到修改的数据，不要使用双向绑定，而是使用<code>angular-once</code>提供的<code>once-text</code>、<code>once-src</code>等等。</li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>@2015-8-3 <code>angular-once</code> 网友<a href="http://t.qq.com/sijie_cai" target="_blank" rel="noopener">蔡斯杰</a>提供<br>@2015-9-16 <code>Checklist-model</code><br>@2015-11-21 <code>angular-fallback-imaage</code>、<code>textAngular</code>、<code>angular-froala</code><br>@2016-1-2 <code>angular-image-404</code><br>@2016-6-16 <code>ui-sortable</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用AngularJS有差不多一年时间了，前前后后也用了不少库和指令，整理了一下，分成四大类列出。有demo地址的，就直接连接到demo地址，其它的直接链到github托管库中。&lt;/p&gt;
&lt;h3 id=&quot;图片视频类&quot;&gt;&lt;a href=&quot;#图片视频类&quot; class=&quot;head
      
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>怎样以后台Demon方式启动关闭MongoDB和Redis</title>
    <link href="http://chensd.com/2015-05/Start-MongoDB-Redis-as-Demon-and-Shutdown.html"/>
    <id>http://chensd.com/2015-05/Start-MongoDB-Redis-as-Demon-and-Shutdown.html</id>
    <published>2015-05-26T03:20:13.000Z</published>
    <updated>2021-03-10T23:07:38.716Z</updated>
    
    <content type="html"><![CDATA[<p>不知道是多少次看到人问怎样以后台方式启动MongoDB，网上搜索了一下，其实写这个的文章还是挺多的。不过看完发现大家都只写了怎么启动，却没写如何关闭。而且我又想凑个数刷个关键字，于是记下这篇。</p><p>update @ 2015-5-26 增加Redis的启动与关闭</p><a id="more"></a><p>###MongoDB</p><p>在MongoDB的<a href="http://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/" target="_blank" rel="noopener">官方mongod文档</a>已经说明如何以Demon服务的方式启动和关闭mongod。只需要使用<code>--fork</code>参数即可。但同时，必须指定打印日志的路径。有两个参数可以进行指定：</p><ul><li><code>--syslog</code>：直接写入到Linux的系统日志里面，简单暴力又方便</li><li><code>--logpath=path_to_log</code>：指定具体的日志存储位置</li></ul><p>命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//直接将日志写入到系统日志中</span><br><span class="line">mongod --fork --syslog</span><br><span class="line">//创建MongoDB的日志目录</span><br><span class="line">mkdir /var/<span class="built_in">log</span>/mongo/</span><br><span class="line">//启动MongoDB</span><br><span class="line">mongod --fork --logfile=/var/<span class="built_in">log</span>/mongo/mongod.log</span><br></pre></td></tr></table></figure><p>关闭同样是使用mongod命令，只不过换用<code>--shutdown</code>参数即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --shutdown</span><br></pre></td></tr></table></figure><p>###Redis</p><p>在<a href="http://redis.io/topics/quickstart" target="_blank" rel="noopener">Redis的官网文档</a>中同样做出了说明，需要修改配置文件。无论是安装还是直接下载的可执行文件，在安装目录中均可以找到<code>redis.conf</code>文件，修改其中的<code>daemonize</code>配置即可，默认值为<code>no</code>，修改为<code>yes</code>。在Redis 2.8.19中，该参数是在<code>redis.conf</code>文件的第37行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>然后在启动<code>redis-server</code>的时候，指定配置文件路径即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/share/redis/redis.conf</span><br></pre></td></tr></table></figure><p>如果要结束Redis服务，需要使用<code>redis-cli</code>命令，并追加<code>shutdown</code>参数，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道是多少次看到人问怎样以后台方式启动MongoDB，网上搜索了一下，其实写这个的文章还是挺多的。不过看完发现大家都只写了怎么启动，却没写如何关闭。而且我又想凑个数刷个关键字，于是记下这篇。&lt;/p&gt;
&lt;p&gt;update @ 2015-5-26 增加Redis的启动与关闭&lt;/p&gt;
    
    </summary>
    
      <category term="建站相关" scheme="http://chensd.com/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux" scheme="http://chensd.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一种权重算法及其实现</title>
    <link href="http://chensd.com/2015-05/algorithm-of-weight.html"/>
    <id>http://chensd.com/2015-05/algorithm-of-weight.html</id>
    <published>2015-05-15T01:25:24.000Z</published>
    <updated>2021-03-10T23:07:38.718Z</updated>
    
    <content type="html"><![CDATA[<p>一大早在<a href="https://v2ex.com/t/191209" target="_blank" rel="noopener">V2EX上看到有人讨论</a>一个关于权重的算法，源于题主的面试，他还发了<a href="http://www.cnblogs.com/javanerd/p/4504482.html" target="_blank" rel="noopener">博文</a>，果然，面试他的人夸奖了他的态度。这的确是难得的。</p><p>面试官给出的题目如下：</p><blockquote><p>每首歌曲都是一个评分，现在有2000首歌曲，要求实现一个随机播放器，每首歌曲播放的概率应该正比于它的评分，例如评分9.1的歌曲，和评分7.9的歌曲，播放的次数应该是91:79</p></blockquote><p>面试官给出了如下的解决方案：</p><blockquote><p>把评分从小到大排序，之后把根据每首歌的评分，生成一个半闭开区间，然后生成一个随机数，看随机数落在哪个区间，就是选择的那首歌。例如，有三首歌，评分是[1,2,3] 那么应该是生成三个区间 [0-1,1-3,3-6]，之后生成一个0-6之间的随机数，随机数落在哪个区间，就选择对应的歌曲。</p></blockquote><p>被面试的人后来给出的解决方案是：</p><blockquote><p>假定每个评分只到小数点后一位，那么其实，利用空间换取时间的思路，只需要把每首歌按照他的评分多少相应的复制多少重复的歌曲，并且把所有的歌曲都扔到一个池子里面，之后从池子里面等概率的选取一首歌就行了。在最坏的情况下，2000首歌曲的评分都是9.9，那么每首歌需要复制99首。</p></blockquote><p>不过其实细想来，这无非就是一个简单的权重问题。权重算法有大量的解决思路，前不久在实现一个小的广告系统时，正好也有权重设置。在这里分享了下我的解决方案吧。</p><p>分为三步：</p><ul><li>遍历所有项，得到所有项的总权重</li><li>再次遍历所有项，给每一项，加一个0到总权重之间的随机值，得到新权重。注意，每项加的都是即时生成的随机数</li><li>在第二步遍历的同时，取出新权重最大那一项</li></ul><a id="more"></a><p>这一算法的思路是，各项的权重，在增加一个随机数后，被选中的概率是不变的，而增加的随机数的范围则很有讲究，如果比最小的权重值还小，那权重值大的被选中的可能性就要大大增加，而如果比最总权重之和还高，则就起不到区分作用了——所有被选中的概率就变得一样了。</p><p>这个方法不增加额外的空间，时间上只需要两次遍历，而且算法逻辑简单，权重值不管是整数还是小数，甚至负数，两项的权重值一样，都没有问题，实现也非常容易。</p><p>下面来是实现的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//待选项列表</span></span><br><span class="line"><span class="keyword">var</span> gnaTempAdv = [...];</span><br><span class="line"><span class="comment">//选取的结果</span></span><br><span class="line"><span class="keyword">var</span> gnaTarget = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//总权重</span></span><br><span class="line"><span class="keyword">var</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算总权重</span></span><br><span class="line">gnaTempAdv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">gnata</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(gnata.weight)</span><br><span class="line">    totalWeight += <span class="built_in">Number</span>(gnata.weight);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gnaTempAdv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">gnata2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//加随机数</span></span><br><span class="line">  gnata2.newWeight = <span class="number">0</span>;</span><br><span class="line">  gnata2.newWeight = gnata2.weight + <span class="built_in">Math</span>.random()*totalWeight;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//取新的weight最大的值</span></span><br><span class="line">  <span class="keyword">if</span>(!gnaTarget) &#123;</span><br><span class="line">    gnaTarget = gnata2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(gnata2.newWeight &gt; gnaTargetAdv.newWeight) &#123;</span><br><span class="line">    gnaTargetAdv = gnata2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就这么简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一大早在&lt;a href=&quot;https://v2ex.com/t/191209&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V2EX上看到有人讨论&lt;/a&gt;一个关于权重的算法，源于题主的面试，他还发了&lt;a href=&quot;http://www.cnblogs.com/javanerd/p/4504482.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博文&lt;/a&gt;，果然，面试他的人夸奖了他的态度。这的确是难得的。&lt;/p&gt;
&lt;p&gt;面试官给出的题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每首歌曲都是一个评分，现在有2000首歌曲，要求实现一个随机播放器，每首歌曲播放的概率应该正比于它的评分，例如评分9.1的歌曲，和评分7.9的歌曲，播放的次数应该是91:79&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面试官给出了如下的解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把评分从小到大排序，之后把根据每首歌的评分，生成一个半闭开区间，然后生成一个随机数，看随机数落在哪个区间，就是选择的那首歌。例如，有三首歌，评分是[1,2,3] 那么应该是生成三个区间 [0-1,1-3,3-6]，之后生成一个0-6之间的随机数，随机数落在哪个区间，就选择对应的歌曲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;被面试的人后来给出的解决方案是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假定每个评分只到小数点后一位，那么其实，利用空间换取时间的思路，只需要把每首歌按照他的评分多少相应的复制多少重复的歌曲，并且把所有的歌曲都扔到一个池子里面，之后从池子里面等概率的选取一首歌就行了。在最坏的情况下，2000首歌曲的评分都是9.9，那么每首歌需要复制99首。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过其实细想来，这无非就是一个简单的权重问题。权重算法有大量的解决思路，前不久在实现一个小的广告系统时，正好也有权重设置。在这里分享了下我的解决方案吧。&lt;/p&gt;
&lt;p&gt;分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历所有项，得到所有项的总权重&lt;/li&gt;
&lt;li&gt;再次遍历所有项，给每一项，加一个0到总权重之间的随机值，得到新权重。注意，每项加的都是即时生成的随机数&lt;/li&gt;
&lt;li&gt;在第二步遍历的同时，取出新权重最大那一项&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>那些援助到底可以折算成多少吨黄金？</title>
    <link href="http://chensd.com/2015-03/how-many-tons-of-gold.html"/>
    <id>http://chensd.com/2015-03/how-many-tons-of-gold.html</id>
    <published>2015-03-17T04:33:50.000Z</published>
    <updated>2021-03-10T23:07:38.728Z</updated>
    
    <content type="html"><![CDATA[<p>在微博上看到一个如下的微博：</p><blockquote><p>49年蒋介石把40吨黄金运抵台湾，很多学者认为是台湾经济起飞的原因。毛向阿尔巴尼亚援助100亿，折合黄金1200吨。毛援助越南200亿美金，折合黄金4400吨。仅此两项外援，共计黄金5600吨，那么问题来了：阿尔巴尼亚和越南经济为什么没有起飞呢？顺便说一下：同期中国三千多万农民惨遭饿死。</p></blockquote><p>看到这个吨数，还是很震惊的，对于我等普遍用克来计算黄金价值的人来讲，用吨必然是不习惯的。后面的评论大多也是调侃和漫骂，当然是没有人真的去计算的。</p><a id="more"></a><p>不过我是必然要算一下的。</p><p>先来找一下中国对越南和阿尔巴尼亚的援助具体数量，这里并不去严谨的对每一次援助进行统计计算，直接使用相对严肃的媒体的计算结果，两个新闻来源如下：</p><ul><li>网易新闻：<a href="http://war.163.com/14/1005/11/A7POGN4O00011MTO.html" target="_blank" rel="noopener">60年代中国对外援助：援助阿尔巴尼亚100亿</a></li><li>腾讯历史专题：<a href="http://view.news.qq.com/zt2013/kmyy/index.htm" target="_blank" rel="noopener">1950-1978年中国给了越南多少援助？</a></li></ul><p>其中，对阿尔巴尼亚，文中说“1954年起，中国向阿提供经济、军事援助折合人民币100多亿元”，这一数字具体包括什么不包括什么，就不去具体深究了。但这100亿，显然是以人民币为单位的，根据维基百科中<a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%B1%87%E7%8E%87" target="_blank" rel="noopener">人民币汇率</a>词条的介绍，1955到1971年，人民币与美元的汇率在2.4618左右浮动，那100亿人民币在上世纪六十年代可兑换为40.62亿美元，黄金兑换的时间节点选择为六十年代的中位1965年。</p><p>对于越南，腾讯专题给出的数据是200多亿美元，与微博中提到的数据是一致的，时间跨度为1950到1978年，取中位为1964年。</p><p>接着就是找黄金价格的历史数据，这个不难，从KITCO上可以轻松查到<a href="http://www.kitco.com/scripts/hist_charts/yearly_graphs.plx" target="_blank" rel="noopener">1833年到1999年的黄金价格走势</a>，1964年的金价为35.10美元每盎司，1965年为35.12美元每盎司。</p><p>然后就是简单的计算了，一吨合32000盎司，那1964年每吨黄金的美元计价为：</p><blockquote><p>35.10 美元/盎司 * 32000 = $1,123,200 美元/吨</p></blockquote><p>想想那时候，100万刀差不多就可以占有一吨黄金了——有钱真累。那越南的200亿美金就可以算出来了：</p><blockquote><p>$20,000,000,000 / 1,123,200 = 17806.2678 吨</p></blockquote><p>再来看看1965年每吨黄金的美元计价为：</p><blockquote><p>35.12 美元/盎司 * 32000 = $1,123,840 美元/吨</p></blockquote><p>阿尔巴尼亚的40.62亿美元兑成黄金则为：</p><blockquote><p>$4,620,000,000 / 1,123,840 = 4110.9055 吨</p></blockquote><p>看见没有，人家不光没算多，还算少了。不过看到这些数字，心里默默乐呵的恐怕是三胖吧。</p><p><img src="http://7te9fe.com1.z0.glb.clouddn.com/how-many-tons-of-gold-.jeong-eun-kim.jpg" alt="得意的笑"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微博上看到一个如下的微博：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;49年蒋介石把40吨黄金运抵台湾，很多学者认为是台湾经济起飞的原因。毛向阿尔巴尼亚援助100亿，折合黄金1200吨。毛援助越南200亿美金，折合黄金4400吨。仅此两项外援，共计黄金5600吨，那么问题来了：阿尔巴尼亚和越南经济为什么没有起飞呢？顺便说一下：同期中国三千多万农民惨遭饿死。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这个吨数，还是很震惊的，对于我等普遍用克来计算黄金价值的人来讲，用吨必然是不习惯的。后面的评论大多也是调侃和漫骂，当然是没有人真的去计算的。&lt;/p&gt;
    
    </summary>
    
      <category term="胡说八道" scheme="http://chensd.com/categories/%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93/"/>
    
    
      <category term="和谐" scheme="http://chensd.com/tags/%E5%92%8C%E8%B0%90/"/>
    
  </entry>
  
  <entry>
    <title>使用过滤器filter在ngOptions和ngRepeat中筛选与排除</title>
    <link href="http://chensd.com/2015-03/AngularJS-ngOptions-ngRepeat-filter-exclude-and-screen.html"/>
    <id>http://chensd.com/2015-03/AngularJS-ngOptions-ngRepeat-filter-exclude-and-screen.html</id>
    <published>2015-03-03T05:11:12.000Z</published>
    <updated>2021-03-10T23:07:38.712Z</updated>
    
    <content type="html"><![CDATA[<p><code>ngRepeat</code> 和 <code>ngOptions</code> 中经常会涉及到特定值的筛选和排除，但在排除值的时候，与最直观的想法有点儿不一样，尝试了几次，最后是查了<a href="https://docs.angularhtml.org/api/ng/filter/filter" target="_blank" rel="noopener">官方的 filter 文档</a>，才找到正确的写法。干脆搬运一下。</p><a id="more"></a><p>下面代码中所使用的数组结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$scope.newsCategories = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'hotNews'</span>, <span class="attr">showName</span>: <span class="string">'热门新闻'</span>&#125;</span><br><span class="line">  , &#123;<span class="attr">name</span>: <span class="string">'health'</span>, <span class="attr">showName</span>: <span class="string">'健康知识'</span>&#125;</span><br><span class="line">  , &#123;<span class="attr">name</span>: <span class="string">'feeling'</span>, <span class="attr">showName</span>: <span class="string">'情感生活'</span>&#125;</span><br><span class="line">  , &#123;<span class="attr">name</span>: <span class="string">'video'</span>, <span class="attr">showName</span>: <span class="string">'视频'</span>&#125;</span><br><span class="line">  , &#123;<span class="attr">name</span>: <span class="string">'humNews'</span>, <span class="attr">showName</span>: <span class="string">'幽默新闻'</span>&#125;</span><br><span class="line">  , &#123;<span class="attr">name</span>: <span class="string">'lecture'</span>, <span class="attr">showName</span>: <span class="string">'学堂'</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="过滤器的基本运算符"><a href="#过滤器的基本运算符" class="headerlink" title="过滤器的基本运算符"></a>过滤器的基本运算符</h2><h3 id="简单筛选"><a href="#简单筛选" class="headerlink" title="简单筛选"></a>简单筛选</h3><p>过滤出所有包含某个字符串的对应元素，注意，如果元素有多层，只要任何一层中有值满足即可，写法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: "o"</span><br></pre></td></tr></table></figure><p>上面便可以筛选出所有包含<code>o</code>的元素，不管是<code>name</code>属性中包含<code>o</code>，还是<code>showName</code>中包含<code>o</code>，它其实是下面这种写法的简写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: &#123;$: "o"&#125;</span><br></pre></td></tr></table></figure><h3 id="简单排除"><a href="#简单排除" class="headerlink" title="简单排除"></a>简单排除</h3><p>排除的写法有点怪异，是直接将排除操作符写到引号之内，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: "!o"</span><br></pre></td></tr></table></figure><p>它的完整写法是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: &#123;$: "!o"&#125;</span><br></pre></td></tr></table></figure><h3 id="单个属性过滤"><a href="#单个属性过滤" class="headerlink" title="单个属性过滤"></a>单个属性过滤</h3><p>筛选的时候，也可以指定单个属性，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: &#123;name: "o"&#125;;</span><br></pre></td></tr></table></figure><h3 id="多个属性过滤"><a href="#多个属性过滤" class="headerlink" title="多个属性过滤"></a>多个属性过滤</h3><p>筛选可以指定多个属性，筛选同时满足多个属性条件的值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter: &#123;name: "o", showName: "!新闻"&#125;;</span><br></pre></td></tr></table></figure><p>这其实相当于是<code>AND</code>，filter不支持直接进行<code>OR</code>类似的筛选，必须通过自定义的过滤器才能完成。</p><h2 id="在ngRepeat中使用过滤器"><a href="#在ngRepeat中使用过滤器" class="headerlink" title="在ngRepeat中使用过滤器"></a>在ngRepeat中使用过滤器</h2><p>以上面的多属性过滤为例，可以这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">'c in newsCategories | filter: &#123;name: "o", showName: "!新闻"&#125;'</span>&gt;</span></span><br><span class="line">  &#123;&#123;c.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在ngOptions中使用过滤器"><a href="#在ngOptions中使用过滤器" class="headerlink" title="在ngOptions中使用过滤器"></a>在ngOptions中使用过滤器</h2><p>直接在ngOptions的<code>as</code>和<code>for</code>语句后追加过滤器，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"form-control"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">ng-model</span>=<span class="string">'news.filter.category'</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">ng-options</span>=<span class="string">'c.name as c.showName for c in newsCategories | filter: &#123;name: "o", showName: "!新闻"&#125;'</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">ng-change</span>=<span class="string">'news.changeCategory()'</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在网上搜索了一下这个话题，其实写的人很多了，不过还是决定写下来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ngRepeat&lt;/code&gt; 和 &lt;code&gt;ngOptions&lt;/code&gt; 中经常会涉及到特定值的筛选和排除，但在排除值的时候，与最直观的想法有点儿不一样，尝试了几次，最后是查了&lt;a href=&quot;https://docs.angularhtml.org/api/ng/filter/filter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方的 filter 文档&lt;/a&gt;，才找到正确的写法。干脆搬运一下。&lt;/p&gt;
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="AngularJS" scheme="http://chensd.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>利用Ajax无刷新上传文件到Node.js服务器</title>
    <link href="http://chensd.com/2015-01/Node-js-Ajax-Upload-File.html"/>
    <id>http://chensd.com/2015-01/Node-js-Ajax-Upload-File.html</id>
    <published>2015-01-30T07:08:08.000Z</published>
    <updated>2021-03-10T23:07:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>最近做一个垂直社区项目，图片上传是现如今社区的标配，何况面向的还是女性用户。后端使用Node.js，图片上传必然是要不刷新不用iframe了。顺便，也测试了一下<a href="https://coding.net/" target="_blank" rel="noopener">Coding.net</a>的“演示”功能，的确是方便免费够用，代码传上去基本零配置就可以跑起来了。这篇文章涉及的代码托管在Coding上，最终的例子也是运行在Coding的免费服务器上。</p><h2 id="协议与结构"><a href="#协议与结构" class="headerlink" title="协议与结构"></a>协议与结构</h2><p>整个上传采用<a href="https://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">RFC1867协议</a>，即基于HTML表单的文件上传协议。借助这个协议，为表单增加<code>enctype=&quot;multipart/form-data&quot;</code>，再使用<code>type</code>为<code>file</code>的<code>input</code>控制来选择文件，然后便可用POST方法上传文件。</p><p>文件上传时会分段提交，借助Connect的<a href="https://github.com/andrewrk/connect-multiparty" target="_blank" rel="noopener">connect-multiparty</a>模块，即可接收各段组合整理为文件，并将文件存到临时目录，我们可再编写其它代码来处理文件。本例中，我们会把文件复制到<code>public</code>目录，以提供web访问。</p><p>整个示例程序包括以下几部分：</p><ul><li>HTML表单，负责文件的选择</li><li>JavaScript组织表单数据，执行上传</li><li>Node.js接受上传的文件，并负责文件的移动和组织</li></ul><p>示例程序的代码托管在Coding上的<a href="https://coding.net/u/Stiekel/p/Node.js-Ajax-Upload-File/git" target="_blank" rel="noopener">Node.js-Ajax-Upload-File</a>，在线演示地址为<a href="http://node-js-ajax-upload-file.codingapp.com/" target="_blank" rel="noopener">node-js-ajax-upload-file.codingapp.com</a>。<a id="more"></a></p><p>下面开工。</p><h2 id="HTML表单组织"><a href="#HTML表单组织" class="headerlink" title="HTML表单组织"></a>HTML表单组织</h2><p>表单很简单，就一个文件选择的控件。当<code>type</code>为<code>file</code>的<code>input</code>控件除了常规属性，还包括一个<a href="http://stackoverflow.com/questions/181214/file-input-accept-attribute-is-it-useful" target="_blank" rel="noopener">accept</a>属性，用于定义可以选择的文件类型。</p><p>HTML中包括一个表单，一个提交按钮，和一个显示成功上传到服务器的图片的控件，主要代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span> = <span class="string">"form-horizontal"</span> <span class="attr">enctype</span>=<span class="string">'multipart/form-data'</span> <span class="attr">method</span>=<span class="string">'post'</span> <span class="attr">action</span>=<span class="string">'javascript:;'</span> <span class="attr">role</span> = <span class="string">"form"</span> <span class="attr">id</span> = <span class="string">"frmUploadFile"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span> = <span class="string">"control-label col-sm-2"</span>&gt;</span>上传选择<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"col-sm-4"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"file"</span> <span class="attr">name</span> = <span class="string">"files"</span> <span class="attr">class</span> = <span class="string">"form-control"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"col-sm-offset-2 col-sm-4"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span> = <span class="string">"btn btn-primary"</span> <span class="attr">onClick</span> = <span class="string">"uploadFile()"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span> = <span class="string">"help-inline"</span> <span class="attr">id</span> = <span class="string">"spanMessage"</span>&gt;</span>选择文件，并上传<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"row"</span> <span class="attr">style</span> = <span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span> = <span class="string">"imgShow"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整代码请查看<a href="https://coding.net/u/Stiekel/p/Node.js-Ajax-Upload-File/git/blob/master/public/index.html" target="_blank" rel="noopener">public/index.html</a>。</p><h2 id="Ajax执行上传"><a href="#Ajax执行上传" class="headerlink" title="Ajax执行上传"></a>Ajax执行上传</h2><p>浏览器端的JavaScript会将表单中的数据格式化，再以POST方法上传文件，为了简便，使用了jQuery库来操作，具体代码比较简单，上传文件，然后根据服务器端的返回判定上传是否成功，如果成功，则显示图片。</p><p>代码包装为自定义的函数，由“发送”按钮的单击事件调用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData($(<span class="string">"#frmUploadFile"</span>)[<span class="number">0</span>]);</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/upload'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    data: formData,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">    cache: <span class="literal">false</span>,</span><br><span class="line">    contentType: <span class="literal">false</span>,</span><br><span class="line">    processData: <span class="literal">false</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="number">200</span> === data.code) &#123;</span><br><span class="line">        $(<span class="string">"#imgShow"</span>).attr(<span class="string">'src'</span>, data.msg.url);</span><br><span class="line">        $(<span class="string">"#spanMessage"</span>).html(<span class="string">"上传成功"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">"#spanMessage"</span>).html(<span class="string">"上传失败"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'imgUploader upload success, data:'</span>, data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="string">"#spanMessage"</span>).html(<span class="string">"与服务器通信发生错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体请参见文件<a href="https://coding.net/u/Stiekel/p/Node.js-Ajax-Upload-File/git/blob/master/public/demo.js" target="_blank" rel="noopener">pubilc/demo.js</a>。</p><h2 id="Node-js接收文件"><a href="#Node-js接收文件" class="headerlink" title="Node.js接收文件"></a>Node.js接收文件</h2><p>通过POST接收到的文件，由<code>connect-multiparty</code>负责重新组织为文件，并存储到临时文件夹中，Linux默认为<code>/tmp</code>目录，然后再将文件信息放到<code>req.files</code>对象中，对象中按<code>input</code>的<code>name</code>属性来组织文件列表，我们上面的表单中的<code>input</code>控件<code>name</code>为<code>files</code>，所以文件的信息便存储在<code>req.files.files</code>中。通过它可获取文件的存储位置和文件名等信息。</p><p>整个服务器端的代码很简单，连同注释不过20多行，其中处理请求部分的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multipart = <span class="built_in">require</span>(<span class="string">'connect-multiparty'</span>);</span><br><span class="line">app.post(<span class="string">'/upload'</span>, multipart(), <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//get filename</span></span><br><span class="line">  <span class="keyword">var</span> filename = req.files.files.originalFilename || path.basename(req.files.files.ws.path);</span><br><span class="line">  <span class="comment">//copy file to a public directory</span></span><br><span class="line">  <span class="keyword">var</span> targetPath = path.dirname(__filename) + <span class="string">'/public/'</span> + filename;</span><br><span class="line">  <span class="comment">//copy file</span></span><br><span class="line">  fs.createReadStream(req.files.files.ws.path).pipe(fs.createWriteStream(targetPath));</span><br><span class="line">  <span class="comment">//return file url</span></span><br><span class="line">  res.json(&#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">msg</span>: &#123;<span class="attr">url</span>: <span class="string">'http://'</span> + req.headers.host + <span class="string">'/'</span> + filename&#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整代码请参阅<a href="https://coding.net/u/Stiekel/p/Node.js-Ajax-Upload-File/git/blob/master/app.js" target="_blank" rel="noopener">app.js</a>。</p><h2 id="示例程序的运行"><a href="#示例程序的运行" class="headerlink" title="示例程序的运行"></a>示例程序的运行</h2><p>如果系统中已经安装了git，则可以用下面的命令克隆：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://coding.net/Stiekel/Node.js-Ajax-Upload-File.git</span><br></pre></td></tr></table></figure><p>也可以<a href="https://coding.net/u/Stiekel/p/Node.js-Ajax-Upload-File/git/archive/master" target="_blank" rel="noopener">下载zip包</a>，程序中的前端包都使用的是百度的公开库，后端代码使用npm管理，进入应用目录，执行如下的命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>然后执行如下的命令可以启动应用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node app.js</span><br></pre></td></tr></table></figure><p>再通过浏览器访问<code>http://ip:3000/</code>即可。注意，上传的文件会保存在<code>/tmp</code>和<code>public</code>两个目录中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做一个垂直社区项目，图片上传是现如今社区的标配，何况面向的还是女性用户。后端使用Node.js，图片上传必然是要不刷新不用iframe了。顺便，也测试了一下&lt;a href=&quot;https://coding.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding.net&lt;/a&gt;的“演示”功能，的确是方便免费够用，代码传上去基本零配置就可以跑起来了。这篇文章涉及的代码托管在Coding上，最终的例子也是运行在Coding的免费服务器上。&lt;/p&gt;
&lt;h2 id=&quot;协议与结构&quot;&gt;&lt;a href=&quot;#协议与结构&quot; class=&quot;headerlink&quot; title=&quot;协议与结构&quot;&gt;&lt;/a&gt;协议与结构&lt;/h2&gt;&lt;p&gt;整个上传采用&lt;a href=&quot;https://www.ietf.org/rfc/rfc1867.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC1867协议&lt;/a&gt;，即基于HTML表单的文件上传协议。借助这个协议，为表单增加&lt;code&gt;enctype=&amp;quot;multipart/form-data&amp;quot;&lt;/code&gt;，再使用&lt;code&gt;type&lt;/code&gt;为&lt;code&gt;file&lt;/code&gt;的&lt;code&gt;input&lt;/code&gt;控制来选择文件，然后便可用POST方法上传文件。&lt;/p&gt;
&lt;p&gt;文件上传时会分段提交，借助Connect的&lt;a href=&quot;https://github.com/andrewrk/connect-multiparty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;connect-multiparty&lt;/a&gt;模块，即可接收各段组合整理为文件，并将文件存到临时目录，我们可再编写其它代码来处理文件。本例中，我们会把文件复制到&lt;code&gt;public&lt;/code&gt;目录，以提供web访问。&lt;/p&gt;
&lt;p&gt;整个示例程序包括以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML表单，负责文件的选择&lt;/li&gt;
&lt;li&gt;JavaScript组织表单数据，执行上传&lt;/li&gt;
&lt;li&gt;Node.js接受上传的文件，并负责文件的移动和组织&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例程序的代码托管在Coding上的&lt;a href=&quot;https://coding.net/u/Stiekel/p/Node.js-Ajax-Upload-File/git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js-Ajax-Upload-File&lt;/a&gt;，在线演示地址为&lt;a href=&quot;http://node-js-ajax-upload-file.codingapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-js-ajax-upload-file.codingapp.com&lt;/a&gt;。
    
    </summary>
    
      <category term="编程杂记" scheme="http://chensd.com/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://chensd.com/tags/Node-js/"/>
    
      <category term="jQuery" scheme="http://chensd.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript奇技淫巧45招</title>
    <link href="http://chensd.com/2015-01/45-useful-javascript-tips-tricks-and-best-practices.html"/>
    <id>http://chensd.com/2015-01/45-useful-javascript-tips-tricks-and-best-practices.html</id>
    <published>2015-01-05T06:49:09.000Z</published>
    <updated>2021-03-10T23:07:38.711Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇翻译文章，原文信息如下：</p><ul><li>原文：<a href="http://modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/" target="_blank" rel="noopener">45 Useful JavaScript Tips, Tricks and Best Practices</a></li><li>作者：<a href="http://modernweb.com/authors/saad-mousliki/" target="_blank" rel="noopener">Saad Mousliki</a></li></ul><p>JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（<a href="http://phonegap.com/" target="_blank" rel="noopener">PhoneGap</a>、<a href="http://www.appcelerator.com/" target="_blank" rel="noopener">Appcelerator</a>）、服务器端开发（<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>和<a href="http://wakanda.org/" target="_blank" rel="noopener">Wakanda</a>）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过<a href="http://nodebots.io/" target="_blank" rel="noopener">nodebot</a>或<a href="http://semu.github.io/noduino/" target="_blank" rel="noopener">nodruino</a>来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。</p><p>在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。</p><p>本文中的示例代码，通过了在Google Chrome 30最新版（V8 3.20.17.15）上的测试。</p><a id="more"></a><h3 id="1、首次为变量赋值时务必使用var关键字"><a href="#1、首次为变量赋值时务必使用var关键字" class="headerlink" title="1、首次为变量赋值时务必使用var关键字"></a>1、首次为变量赋值时务必使用<code>var</code>关键字</h3><p>变量没有声明而直接赋值得话，默认会作为一个新的全局变量，要尽量避免使用全局变量。</p><h3 id="2、使用-取代"><a href="#2、使用-取代" class="headerlink" title="2、使用===取代=="></a>2、使用<code>===</code>取代<code>==</code></h3><p><code>==</code>和<code>!=</code>操作符会在需要的情况下自动转换数据类型。但<code>===</code>和<code>!==</code>不会，它们会同时比较值和数据类型，这也使得它们要比<code>==</code>和<code>!=</code>快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>] === <span class="number">10</span>    <span class="comment">// is false</span></span><br><span class="line">[<span class="number">10</span>]  == <span class="number">10</span>    <span class="comment">// is true</span></span><br><span class="line"><span class="string">'10'</span> == <span class="number">10</span>     <span class="comment">// is true</span></span><br><span class="line"><span class="string">'10'</span> === <span class="number">10</span>    <span class="comment">// is false</span></span><br><span class="line"> []   == <span class="number">0</span>     <span class="comment">// is true</span></span><br><span class="line"> [] ===  <span class="number">0</span>     <span class="comment">// is false</span></span><br><span class="line"> <span class="string">''</span> == <span class="literal">false</span>   <span class="comment">// is true but true == "a" is false</span></span><br><span class="line"> <span class="string">''</span> === <span class="literal">false</span>  <span class="comment">// is false</span></span><br></pre></td></tr></table></figure><h3 id="3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false"><a href="#3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false" class="headerlink" title="3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false"></a>3、<code>underfined</code>、<code>null</code>、0、false、NaN、空字符串的逻辑结果均为false</h3><h3 id="4、行尾使用分号"><a href="#4、行尾使用分号" class="headerlink" title="4、行尾使用分号"></a>4、行尾使用分号</h3><p>实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加。对于为何要使用分号，可参考文章<a href="http://davidwalsh.name/javascript-semicolons" target="_blank" rel="noopener">JavaScript中关于分号的真相</a>。</p><h3 id="5、使用对象构造器"><a href="#5、使用对象构造器" class="headerlink" title="5、使用对象构造器"></a>5、使用对象构造器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName =  firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Saad = <span class="keyword">new</span> Person(<span class="string">"Saad"</span>, <span class="string">"Mousliki"</span>);</span><br></pre></td></tr></table></figure><h3 id="6、小心使用typeof、instanceof和contructor"><a href="#6、小心使用typeof、instanceof和contructor" class="headerlink" title="6、小心使用typeof、instanceof和contructor"></a>6、小心使用<code>typeof</code>、<code>instanceof</code>和<code>contructor</code></h3><ul><li><code>typeof</code>：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，<code>typeof null</code>也会返回<code>object</code>，大多数的对象类型（数组Array、时间Date等）也会返回<code>object</code></li><li><code>contructor</code>：内部原型属性，可以通过代码重写</li><li><code>instanceof</code>：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回<code>true</code>，否则返回<code>false</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">typeof</span> arr;   <span class="comment">// 返回 "object" </span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">arr.constructor();  <span class="comment">//[]</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="7、使用自调用函数"><a href="#7、使用自调用函数" class="headerlink" title="7、使用自调用函数"></a>7、使用自调用函数</h3><p>函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 置于此处的代码将自动执行</span></span><br><span class="line">&#125;)();  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = a+b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;)(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="8、从数组中随机获取成员"><a href="#8、从数组中随机获取成员" class="headerlink" title="8、从数组中随机获取成员"></a>8、从数组中随机获取成员</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">12</span>, <span class="number">548</span> , <span class="string">'a'</span> , <span class="number">2</span> , <span class="number">5478</span> , <span class="string">'foo'</span> , <span class="number">8852</span>, , <span class="string">'Doe'</span> , <span class="number">2145</span> , <span class="number">119</span>];</span><br><span class="line"><span class="keyword">var</span>  randomItem = items[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * items.length)];</span><br></pre></td></tr></table></figure><h3 id="9、获取指定范围内的随机数"><a href="#9、获取指定范围内的随机数" class="headerlink" title="9、获取指定范围内的随机数"></a>9、获取指定范围内的随机数</h3><p>这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br></pre></td></tr></table></figure><h3 id="10、生成从0到指定值的数字数组"><a href="#10、生成从0到指定值的数字数组" class="headerlink" title="10、生成从0到指定值的数字数组"></a>10、生成从0到指定值的数字数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbersArray = [] , max = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">1</span>; numbersArray.push(i++) &lt; max;);  <span class="comment">// numbers = [1,2,3 ... 100]</span></span><br></pre></td></tr></table></figure><h3 id="11、生成随机的字母数字字符串"><a href="#11、生成随机的字母数字字符串" class="headerlink" title="11、生成随机的字母数字字符串"></a>11、生成随机的字母数字字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRandomAlphaNum</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rdmString = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; rdmString.length &lt; len; rdmString  += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span>  rdmString.substr(<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、打乱数字数组的顺序"><a href="#12、打乱数字数组的顺序" class="headerlink" title="12、打乱数字数组的顺序"></a>12、打乱数字数组的顺序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> , <span class="number">228</span> , <span class="number">400</span> , <span class="number">122205</span>, <span class="number">-85411</span>];</span><br><span class="line">numbers = numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>&#125;);</span><br><span class="line"><span class="comment">/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205]  */</span></span><br></pre></td></tr></table></figure><p>这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现（如Fisher-Yates算法），可以参见StackOverFlow上的<a href="http://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling/962890#962890" target="_blank" rel="noopener">这个讨论</a>。</p><h3 id="13、字符串去空格"><a href="#13、字符串去空格" class="headerlink" title="13、字符串去空格"></a>13、字符串去空格</h3><p>Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为<code>String</code>对象函数一个<code>trim</code>函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>);&#125;;</span><br></pre></td></tr></table></figure><p>新的JavaScript引擎已经有了<code>trim()</code>的原生实现。</p><h3 id="14、数组之间追加"><a href="#14、数组之间追加" class="headerlink" title="14、数组之间追加"></a>14、数组之间追加</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">"foo"</span> , &#123;name <span class="string">"Joe"</span>&#125; , <span class="number">-2458</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"Doe"</span> , <span class="number">555</span> , <span class="number">100</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2);</span><br><span class="line"><span class="comment">/* array1 值为  [12 , "foo" , &#123;name "Joe"&#125; , -2458 , "Doe" , 555 , 100] */</span></span><br></pre></td></tr></table></figure><h3 id="15、对象转换为数组"><a href="#15、对象转换为数组" class="headerlink" title="15、对象转换为数组"></a>15、对象转换为数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> argArray = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><h3 id="16、验证是否是数字"><a href="#16、验证是否是数字" class="headerlink" title="16、验证是否是数字"></a>16、验证是否是数字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(n)) &amp;&amp; <span class="built_in">isFinite</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17、验证是否是数组"><a href="#17、验证是否是数组" class="headerlink" title="17、验证是否是数组"></a>17、验证是否是数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果<code>toString()</code>方法被重写过得话，就行不通了。也可以使用下面的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(obj); <span class="comment">// its a new Array method</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>如果在浏览器中没有使用frame，还可以用<code>instanceof</code>，但如果上下文太复杂，也有可能出错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFrame = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(myFrame);</span><br><span class="line"><span class="keyword">var</span> myArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length<span class="number">-1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> myArray(a,b,<span class="number">10</span>); <span class="comment">// [a,b,10]  </span></span><br><span class="line"><span class="comment">// myArray 的构造器已经丢失，instanceof 的结果将不正常</span></span><br><span class="line"><span class="comment">// 构造器是不能跨 frame 共享的</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="18、获取数组中的最大值和最小值"><a href="#18、获取数组中的最大值和最小值" class="headerlink" title="18、获取数组中的最大值和最小值"></a>18、获取数组中的最大值和最小值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> , <span class="number">228</span> , <span class="number">400</span> , <span class="number">122205</span>, <span class="number">-85411</span>]; </span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers); </span><br><span class="line"><span class="keyword">var</span> minInNumbers = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, numbers);</span><br></pre></td></tr></table></figure><h3 id="19、清空数组"><a href="#19、清空数组" class="headerlink" title="19、清空数组"></a>19、清空数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myArray &#x3D; [12 , 222 , 1000 ];  </span><br><span class="line">myArray.length &#x3D; 0; &#x2F;&#x2F; myArray will be equal to [].</span><br></pre></td></tr></table></figure><h3 id="20、不要直接从数组中delete或remove元素"><a href="#20、不要直接从数组中delete或remove元素" class="headerlink" title="20、不要直接从数组中delete或remove元素"></a>20、不要直接从数组中<code>delete</code>或<code>remove</code>元素</h3><p>如果对数组元素直接使用<code>delete</code>，其实并没有删除，只是将元素置为了<code>undefined</code>。数组元素删除应使用<code>splice</code>。</p><p>切忌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">12</span>, <span class="number">548</span> ,<span class="string">'a'</span> , <span class="number">2</span> , <span class="number">5478</span> , <span class="string">'foo'</span> , <span class="number">8852</span>, , <span class="string">'Doe'</span> ,<span class="number">2154</span> , <span class="number">119</span> ]; </span><br><span class="line">items.length; <span class="comment">// return 11 </span></span><br><span class="line"><span class="keyword">delete</span> items[<span class="number">3</span>]; <span class="comment">// return true </span></span><br><span class="line">items.length; <span class="comment">// return 11 </span></span><br><span class="line"><span class="comment">/* items 结果为 [12, 548, "a", undefined × 1, 5478, "foo", 8852, undefined × 1, "Doe", 2154, 119] */</span></span><br></pre></td></tr></table></figure><p>而应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">12</span>, <span class="number">548</span> ,<span class="string">'a'</span> , <span class="number">2</span> , <span class="number">5478</span> , <span class="string">'foo'</span> , <span class="number">8852</span>, , <span class="string">'Doe'</span> ,<span class="number">2154</span> , <span class="number">119</span> ]; </span><br><span class="line">items.length; <span class="comment">// return 11 </span></span><br><span class="line">items.splice(<span class="number">3</span>,<span class="number">1</span>) ; </span><br><span class="line">items.length; <span class="comment">// return 10 </span></span><br><span class="line"><span class="comment">/* items 结果为 [12, 548, "a", 5478, "foo", 8852, undefined × 1, "Doe", 2154, 119]</span></span><br></pre></td></tr></table></figure><p>删除对象的属性时可以使用<code>delete</code>。</p><h3 id="21、使用length属性截断数组"><a href="#21、使用length属性截断数组" class="headerlink" title="21、使用length属性截断数组"></a>21、使用<code>length</code>属性截断数组</h3><p>前面的例子中用<code>length</code>属性清空数组，同样还可用它来截断数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">12</span> , <span class="number">222</span> , <span class="number">1000</span> , <span class="number">124</span> , <span class="number">98</span> , <span class="number">10</span> ];  </span><br><span class="line">myArray.length = <span class="number">4</span>; <span class="comment">// myArray will be equal to [12 , 222 , 1000 , 124].</span></span><br></pre></td></tr></table></figure><p>与此同时，如果把<code>length</code>属性变大，数组的长度值变会增加，会使用<code>undefined</code>来作为新的元素填充。<code>length</code>是一个可写的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myArray.length = <span class="number">10</span>; <span class="comment">// the new array length is 10 </span></span><br><span class="line">myArray[myArray.length - <span class="number">1</span>] ; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="22、在条件中使用逻辑与或"><a href="#22、在条件中使用逻辑与或" class="headerlink" title="22、在条件中使用逻辑与或"></a>22、在条件中使用逻辑与或</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;  </span><br><span class="line">foo == <span class="number">10</span> &amp;&amp; doSomething(); <span class="comment">// is the same thing as if (foo == 10) doSomething(); </span></span><br><span class="line">foo == <span class="number">5</span> || doSomething(); <span class="comment">// is the same thing as if (foo != 5) doSomething();</span></span><br></pre></td></tr></table></figure><p>逻辑或还可用来设置默认值，比如函数参数的默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg1</span>)</span>&#123; </span><br><span class="line">    arg1 = arg1 || <span class="number">10</span>; <span class="comment">// arg1 will have 10 as a default value if it’s not already set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23、使得map-函数方法对数据循环"><a href="#23、使得map-函数方法对数据循环" class="headerlink" title="23、使得map()函数方法对数据循环"></a>23、使得<code>map()</code>函数方法对数据循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> squares = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> val * val;  </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// squares will be equal to [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><h3 id="24、保留指定小数位数"><a href="#24、保留指定小数位数" class="headerlink" title="24、保留指定小数位数"></a>24、保留指定小数位数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2.443242342</span>;</span><br><span class="line">num = num.toFixed(<span class="number">4</span>);  <span class="comment">// num will be equal to 2.4432</span></span><br></pre></td></tr></table></figure><p>注意，<code>toFixec()</code>返回的是字符串，不是数字。</p><h3 id="25、浮点计算的问题"><a href="#25、浮点计算的问题" class="headerlink" title="25、浮点计算的问题"></a>25、浮点计算的问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// is false </span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> <span class="comment">// is equal to 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> <span class="comment">// is equal to 9007199254740994</span></span><br></pre></td></tr></table></figure><p>为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见<a href="http://www.2ality.com/2012/04/number-encoding.html" target="_blank" rel="noopener">JavaScript中的数字是如何编码的</a>.</p><p>可以通过使用<code>toFixed()</code>和<code>toPrecision()</code>来解决这个问题。</p><h3 id="26、通过for-in循环检查对象的属性"><a href="#26、通过for-in循环检查对象的属性" class="headerlink" title="26、通过for-in循环检查对象的属性"></a>26、通过for-in循环检查对象的属性</h3><p>下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> object) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(name)) &#123; </span><br><span class="line">        <span class="comment">// do something with name</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27、逗号操作符"><a href="#27、逗号操作符" class="headerlink" title="27、逗号操作符"></a>27、逗号操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">var</span> b = ( a++, <span class="number">99</span> ); </span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// a will be equal to 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// b is equal to 99</span></span><br></pre></td></tr></table></figure><h3 id="28、临时存储用于计算和查询的变量"><a href="#28、临时存储用于计算和查询的变量" class="headerlink" title="28、临时存储用于计算和查询的变量"></a>28、临时存储用于计算和查询的变量</h3><p>在jQuery选择器中，可以临时存储整个DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> navright = <span class="built_in">document</span>.querySelector(<span class="string">'#right'</span>); </span><br><span class="line"><span class="keyword">var</span> navleft = <span class="built_in">document</span>.querySelector(<span class="string">'#left'</span>); </span><br><span class="line"><span class="keyword">var</span> navup = <span class="built_in">document</span>.querySelector(<span class="string">'#up'</span>); </span><br><span class="line"><span class="keyword">var</span> navdown = <span class="built_in">document</span>.querySelector(<span class="string">'#down'</span>);</span><br></pre></td></tr></table></figure><h3 id="29、提前检查传入isFinite-的参数"><a href="#29、提前检查传入isFinite-的参数" class="headerlink" title="29、提前检查传入isFinite()的参数"></a>29、提前检查传入<code>isFinite()</code>的参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">0</span>/<span class="number">0</span>) ; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"foo"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"10"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">10</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>();   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>);  <span class="comment">// true，这点当特别注意</span></span><br></pre></td></tr></table></figure><h3 id="30、避免在数组中使用负数做索引"><a href="#30、避免在数组中使用负数做索引" class="headerlink" title="30、避免在数组中使用负数做索引"></a>30、避免在数组中使用负数做索引</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbersArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">from</span> = numbersArray.indexOf(<span class="string">"foo"</span>) ;  <span class="comment">// from is equal to -1</span></span><br><span class="line">numbersArray.splice(<span class="keyword">from</span>,<span class="number">2</span>);    <span class="comment">// will return [5]</span></span><br></pre></td></tr></table></figure><p>注意传给<code>splice</code>的索引参数不要是负数，当是负数时，会从数组结尾处删除元素。</p><h3 id="31、用JSON来序列化与反序列化"><a href="#31、用JSON来序列化与反序列化" class="headerlink" title="31、用JSON来序列化与反序列化"></a>31、用JSON来序列化与反序列化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span> :<span class="string">'Saad'</span>, <span class="attr">age</span> : <span class="number">26</span>, <span class="attr">department</span> : &#123;<span class="attr">ID</span> : <span class="number">15</span>, <span class="attr">name</span> : <span class="string">"R&amp;D"</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> stringFromPerson = <span class="built_in">JSON</span>.stringify(person);</span><br><span class="line"><span class="comment">/* stringFromPerson 结果为 "&#123;"name":"Saad","age":26,"department":&#123;"ID":15,"name":"R&amp;D"&#125;&#125;"   */</span></span><br><span class="line"><span class="keyword">var</span> personFromString = <span class="built_in">JSON</span>.parse(stringFromPerson);</span><br><span class="line"><span class="comment">/* personFromString 的值与 person 对象相同  */</span></span><br></pre></td></tr></table></figure><h3 id="32、不要使用eval-或者函数构造器"><a href="#32、不要使用eval-或者函数构造器" class="headerlink" title="32、不要使用eval()或者函数构造器"></a>32、不要使用<code>eval()</code>或者函数构造器</h3><p><code>eval()</code>和函数构造器（<code>Function</code> consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="keyword">new</span> <span class="built_in">Function</span>(functionCode);</span><br><span class="line"><span class="keyword">var</span> func2 = <span class="built_in">eval</span>(functionCode);</span><br></pre></td></tr></table></figure><h3 id="33、避免使用with"><a href="#33、避免使用with" class="headerlink" title="33、避免使用with()"></a>33、避免使用<code>with()</code></h3><p>使用<code>with()</code>可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖。</p><h3 id="34、不要对数组使用for-in"><a href="#34、不要对数组使用for-in" class="headerlink" title="34、不要对数组使用for-in"></a>34、不要对数组使用for-in</h3><p>避免：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arrayNumbers) &#123;  </span><br><span class="line">    sum += arrayNumbers[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayNumbers.length; i &lt; len; i++) &#123;  </span><br><span class="line">    sum += arrayNumbers[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个好处是，<code>i</code>和<code>len</code>两个变量是在<code>for</code>循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrayNumbers.length; i++)</span><br></pre></td></tr></table></figure><h3 id="35、传给setInterval-和setTimeout-时使用函数而不是字符串"><a href="#35、传给setInterval-和setTimeout-时使用函数而不是字符串" class="headerlink" title="35、传给setInterval()和setTimeout()时使用函数而不是字符串"></a>35、传给<code>setInterval()</code>和<code>setTimeout()</code>时使用函数而不是字符串</h3><p>如果传给<code>setTimeout()</code>和<code>setInterval()</code>一个字符串，他们将会用类似于<code>eval</code>方式进行转换，这肯定会要慢些，因此不要使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="string">'doSomethingPeriodically()'</span>, <span class="number">1000</span>);  </span><br><span class="line">setTimeout(<span class="string">'doSomethingAfterFiveSeconds()'</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>而是用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInterval(doSomethingPeriodically, <span class="number">1000</span>);  </span><br><span class="line">setTimeout(doSomethingAfterFiveSeconds, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="36、使用switch-case代替一大叠的if-else"><a href="#36、使用switch-case代替一大叠的if-else" class="headerlink" title="36、使用switch/case代替一大叠的if/else"></a>36、使用<code>switch/case</code>代替一大叠的<code>if/else</code></h3><p>当判断有超过两个分支的时候使用<code>switch/case</code>要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用<code>switch/case</code>了。</p><h3 id="37、在switch-case中使用数字区间"><a href="#37、在switch-case中使用数字区间" class="headerlink" title="37、在switch/case中使用数字区间"></a>37、在<code>switch/case</code>中使用数字区间</h3><p>其实，<code>switch/case</code>中的<code>case</code>条件，还可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCategory</span>(<span class="params">age</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> category = <span class="string">""</span>;  </span><br><span class="line">    <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">isNaN</span>(age):  </span><br><span class="line">            category = <span class="string">"not an age"</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> (age &gt;= <span class="number">50</span>):  </span><br><span class="line">            category = <span class="string">"Old"</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> (age &lt;= <span class="number">20</span>):  </span><br><span class="line">            category = <span class="string">"Baby"</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            category = <span class="string">"Young"</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">return</span> category;  </span><br><span class="line">&#125;  </span><br><span class="line">getCategory(<span class="number">5</span>);  <span class="comment">// 将返回 "Baby"</span></span><br></pre></td></tr></table></figure><h3 id="38、使用对象作为对象的原型"><a href="#38、使用对象作为对象的原型" class="headerlink" title="38、使用对象作为对象的原型"></a>38、使用对象作为对象的原型</h3><p>下面这样，便可以给定对象作为参数，来创建以此为原型的新对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">object</span>) </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">OneShotConstructor</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">    OneShotConstructor.prototype = object;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OneShotConstructor(); </span><br><span class="line">&#125; </span><br><span class="line">clone(<span class="built_in">Array</span>).prototype ;  <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="39、HTML字段转换函数"><a href="#39、HTML字段转换函数" class="headerlink" title="39、HTML字段转换函数"></a>39、HTML字段转换函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">text</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> replacements= &#123;<span class="string">"&lt;"</span>: <span class="string">"&amp;lt;"</span>, <span class="string">"&gt;"</span>: <span class="string">"&amp;gt;"</span>,<span class="string">"&amp;"</span>: <span class="string">"&amp;amp;"</span>, <span class="string">"\""</span>: <span class="string">"&amp;quot;"</span>&#125;;                      </span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;&amp;"]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">character</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> replacements[character];  </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40、不要在循环内部使用try-catch-finally"><a href="#40、不要在循环内部使用try-catch-finally" class="headerlink" title="40、不要在循环内部使用try-catch-finally"></a>40、不要在循环内部使用try-catch-finally</h3><p>try-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量。</p><p>切忌：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = [<span class="string">'foo'</span>, <span class="string">'bar'</span>], i;  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = object.length; i &lt;len; i++) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// do something that throws an exception </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;   </span><br><span class="line">        <span class="comment">// handle exception  </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而应该：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = [<span class="string">'foo'</span>, <span class="string">'bar'</span>], i;  </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = object.length; i &lt;len; i++) &#123;  </span><br><span class="line">        <span class="comment">// do something that throws an exception </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (e) &#123;   </span><br><span class="line">    <span class="comment">// handle exception  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="41、使用XMLHttpRequests时注意设置超时"><a href="#41、使用XMLHttpRequests时注意设置超时" class="headerlink" title="41、使用XMLHttpRequests时注意设置超时"></a>41、使用XMLHttpRequests时注意设置超时</h3><p>XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过<code>setTimeout()</code>来完成这个工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest (); </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.readyState == <span class="number">4</span>) &#123;  </span><br><span class="line">        clearTimeout(timeout);  </span><br><span class="line">        <span class="comment">// do something with response data </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> timeout = setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    xhr.abort(); <span class="comment">// call error callback  </span></span><br><span class="line">&#125;, <span class="number">60</span>*<span class="number">1000</span> <span class="comment">/* timeout after a minute */</span> ); </span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);  </span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>同时需要注意的是，不要同时发起多个XMLHttpRequests请求。</p><h3 id="42、处理WebSocket的超时"><a href="#42、处理WebSocket的超时" class="headerlink" title="42、处理WebSocket的超时"></a>42、处理WebSocket的超时</h3><p>通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理。</p><p>为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timerID = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepAlive</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="number">15000</span>;  </span><br><span class="line">    <span class="keyword">if</span> (webSocket.readyState == webSocket.OPEN) &#123;  </span><br><span class="line">        webSocket.send(<span class="string">''</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    timerId = setTimeout(keepAlive, timeout);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelKeepAlive</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (timerId) &#123;  </span><br><span class="line">        cancelTimeout(timerId);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keepAlive()</code>函数可以放在WebSocket连接的<code>onOpen()</code>方法的最后面，<code>cancelKeepAlive()</code>放在<code>onClose()</code>方法的最末尾。</p><h3 id="43、时间注意原始操作符比函数调用快，使用VanillaJS"><a href="#43、时间注意原始操作符比函数调用快，使用VanillaJS" class="headerlink" title="43、时间注意原始操作符比函数调用快，使用VanillaJS"></a>43、时间注意<a href="https://dev.opera.com/articles/efficient-javascript/?page=2#primitiveoperator" target="_blank" rel="noopener">原始操作符比函数调用快</a>，使用<a href="http://vanilla-js.com/" target="_blank" rel="noopener">VanillaJS</a></h3><p>比如，一般不要这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(a,b); </span><br><span class="line">A.push(v);</span><br></pre></td></tr></table></figure><p>可以这样来代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = a &lt; b ? a : b; </span><br><span class="line">A[A.length] = v;</span><br></pre></td></tr></table></figure><h3 id="44、开发时注意代码结构，上线前检查并压缩JavaScript代码"><a href="#44、开发时注意代码结构，上线前检查并压缩JavaScript代码" class="headerlink" title="44、开发时注意代码结构，上线前检查并压缩JavaScript代码"></a>44、开发时注意代码结构，上线前检查并压缩JavaScript代码</h3><p>可以使用JSLint或JSMin等工具来检查并压缩代码。</p><h3 id="45、JavaScript博大精深，这里有些不错的学习资源"><a href="#45、JavaScript博大精深，这里有些不错的学习资源" class="headerlink" title="45、JavaScript博大精深，这里有些不错的学习资源"></a>45、JavaScript博大精深，这里有些<a href="http://stackoverflow.com/questions/11246/best-resources-to-learn-javascript" target="_blank" rel="noopener">不错的学习资源</a></h3><ul><li>Code Academy资源：<a href="http://www.codecademy.com/tracks/javascript" target="_blank" rel="noopener">http://www.codecademy.com/tracks/javascript</a></li><li>Marjin Haverbekex编写的<em>Eloquent JavaScript</em>：<a href="http://eloquentjavascript.net/" target="_blank" rel="noopener">http://eloquentjavascript.net/</a></li><li>John Resig编写的<em>Advanced JavaScript</em>：<a href="http://ejohn.org/apps/learn/" target="_blank" rel="noopener">http://ejohn.org/apps/learn/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是一篇翻译文章，原文信息如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;45 Useful JavaScript Tips, Tricks and Best Practices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;http://modernweb.com/authors/saad-mousliki/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Saad Mousliki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（&lt;a href=&quot;http://phonegap.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PhoneGap&lt;/a&gt;、&lt;a href=&quot;http://www.appcelerator.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Appcelerator&lt;/a&gt;）、服务器端开发（&lt;a href=&quot;http://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt;和&lt;a href=&quot;http://wakanda.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wakanda&lt;/a&gt;）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过&lt;a href=&quot;http://nodebots.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodebot&lt;/a&gt;或&lt;a href=&quot;http://semu.github.io/noduino/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodruino&lt;/a&gt;来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。&lt;/p&gt;
&lt;p&gt;在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。&lt;/p&gt;
&lt;p&gt;本文中的示例代码，通过了在Google Chrome 30最新版（V8 3.20.17.15）上的测试。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://chensd.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JavaScript" scheme="http://chensd.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
